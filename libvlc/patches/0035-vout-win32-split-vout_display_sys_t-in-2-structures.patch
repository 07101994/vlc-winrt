From cf93239d5e8b28811057950bc0276638f72b1e30 Mon Sep 17 00:00:00 2001
From: Steve Lhomme <robux4@videolabs.io>
Date: Mon, 23 Jan 2017 15:08:11 +0100
Subject: [PATCH 35/53] vout: win32: split vout_display_sys_t in 2 structures

One really common becomes vout_display_sys_win32_t, the other one remains
vout_display_sys_t.

use_desktop and use_overlay have been moved in the common structure for
convenience.
---
 modules/video_output/win32/common.c     |  22 +++----
 modules/video_output/win32/common.h     |  25 +++++---
 modules/video_output/win32/direct3d11.c |  52 +++++++--------
 modules/video_output/win32/direct3d9.c  |  86 ++++++++++++-------------
 modules/video_output/win32/directdraw.c | 108 ++++++++++++++++----------------
 modules/video_output/win32/events.c     |   2 +-
 modules/video_output/win32/glwin32.c    |  20 +++---
 modules/video_output/win32/wgl.c        |   8 +--
 modules/video_output/win32/wingdi.c     |  30 ++++-----
 9 files changed, 179 insertions(+), 174 deletions(-)

diff --git a/modules/video_output/win32/common.c b/modules/video_output/win32/common.c
index ee444f9..9261169 100644
--- a/modules/video_output/win32/common.c
+++ b/modules/video_output/win32/common.c
@@ -59,7 +59,7 @@ static void RestoreScreensaver(vout_display_t *);
 /* */
 int CommonInit(vout_display_t *vd)
 {
-    vout_display_sys_t *sys = vd->sys;
+    vout_display_sys_win32_t *sys = &vd->sys->sys;
 
     sys->hwnd      = NULL;
     sys->hvideownd = NULL;
@@ -124,7 +124,7 @@ int CommonInit(vout_display_t *vd)
 picture_pool_t *CommonPool(vout_display_t *vd, unsigned count)
 {
     VLC_UNUSED(count);
-    return vd->sys->pool;
+    return vd->sys->sys.pool;
 }
 
 /*****************************************************************************
@@ -139,7 +139,7 @@ void UpdateRects(vout_display_t *vd,
     const video_format_t *source,
     bool is_forced)
 {
-    vout_display_sys_t *sys = vd->sys;
+    vout_display_sys_win32_t *sys = &vd->sys->sys;
 #define rect_src sys->rect_src
 #define rect_src_clipped sys->rect_src_clipped
 #define rect_dest sys->rect_dest
@@ -355,7 +355,7 @@ exit:
 /* */
 void CommonClean(vout_display_t *vd)
 {
-    vout_display_sys_t *sys = vd->sys;
+    vout_display_sys_win32_t *sys = &vd->sys->sys;
     if (sys->event) {
         CommonChangeThumbnailClip(vd, false);
         EventThreadStop(sys->event);
@@ -382,7 +382,7 @@ void CommonClean(vout_display_t *vd)
 
 void CommonManage(vout_display_t *vd)
 {
-    vout_display_sys_t *sys = vd->sys;
+    vout_display_sys_win32_t *sys = &vd->sys->sys;
 
     /* We used to call the Win32 PeekMessage function here to read the window
      * messages. But since window can stay blocked into this function for a
@@ -432,7 +432,7 @@ void CommonManage(vout_display_t *vd)
  */
 void CommonDisplay(vout_display_t *vd)
 {
-    vout_display_sys_t *sys = vd->sys;
+    vout_display_sys_win32_t *sys = &vd->sys->sys;
     if (!sys->is_first_display)
         return;
 
@@ -536,7 +536,7 @@ void AlignRect(RECT *r, int align_boundary, int align_size)
 /* */
 static void CommonChangeThumbnailClip(vout_display_t *vd, bool show)
 {
-    vout_display_sys_t *sys = vd->sys;
+    vout_display_sys_win32_t *sys = &vd->sys->sys;
 
     /* Windows 7 taskbar thumbnail code */
     OSVERSIONINFO winVer;
@@ -578,7 +578,7 @@ static void CommonChangeThumbnailClip(vout_display_t *vd, bool show)
 
 static int CommonControlSetFullscreen(vout_display_t *vd, bool is_fullscreen)
 {
-    vout_display_sys_t *sys = vd->sys;
+    vout_display_sys_win32_t *sys = &vd->sys->sys;
 
 #ifdef MODULE_NAME_IS_direct3d9
     if (sys->use_desktop && is_fullscreen)
@@ -665,7 +665,7 @@ static int CommonControlSetFullscreen(vout_display_t *vd, bool is_fullscreen)
 
 int CommonControl(vout_display_t *vd, int query, va_list args)
 {
-    vout_display_sys_t *sys = vd->sys;
+    vout_display_sys_win32_t *sys = &vd->sys->sys;
 
     switch (query) {
     case VOUT_DISPLAY_CHANGE_DISPLAY_SIZE:   /* const vout_display_cfg_t *p_cfg */
@@ -741,7 +741,7 @@ int CommonControl(vout_display_t *vd, int query, va_list args)
 
 static void DisableScreensaver(vout_display_t *vd)
 {
-    vout_display_sys_t *sys = vd->sys;
+    vout_display_sys_win32_t *sys = &vd->sys->sys;
 
     /* disable screensaver by temporarily changing system settings */
     sys->i_spi_screensaveactive = 0;
@@ -758,7 +758,7 @@ static void DisableScreensaver(vout_display_t *vd)
 
 static void RestoreScreensaver(vout_display_t *vd)
 {
-    vout_display_sys_t *sys = vd->sys;
+    vout_display_sys_win32_t *sys = &vd->sys->sys;
 
     /* restore screensaver system settings */
     if (0 != sys->i_spi_screensaveactive) {
diff --git a/modules/video_output/win32/common.h b/modules/video_output/win32/common.h
index e6e1d77..a95bfe1 100644
--- a/modules/video_output/win32/common.h
+++ b/modules/video_output/win32/common.h
@@ -78,7 +78,7 @@ extern const GUID GUID_SWAPCHAIN_HEIGHT;
  * This structure is part of the video output thread descriptor.
  * It describes the module specific properties of an output thread.
  *****************************************************************************/
-struct vout_display_sys_t
+typedef struct vout_display_sys_win32_t
 {
     /* */
     event_thread_t *event;
@@ -117,20 +117,27 @@ struct vout_display_sys_t
 
     picture_pool_t *pool;
 
+    bool use_desktop;     /* show video on desktop window ? */
+
+    bool use_overlay;     /* Are we using an overlay surface */
+    /* Overlay alignment restrictions */
+    int  i_align_src_boundary;
+    int  i_align_src_size;
+    int  i_align_dest_boundary;
+    int  i_align_dest_size;
+} vout_display_sys_win32_t;
+
+
+struct vout_display_sys_t
+{
+    vout_display_sys_win32_t sys;
 #ifdef MODULE_NAME_IS_directdraw
     /* Multi-monitor support */
     HMONITOR             hmonitor;          /* handle of the current monitor */
     GUID                 *display_driver;
 
-    /* Overlay alignment restrictions */
-    int          i_align_src_boundary;
-    int          i_align_src_size;
-    int          i_align_dest_boundary;
-    int          i_align_dest_size;
-
     bool   use_wallpaper;   /* show as desktop wallpaper ? */
 
-    bool   use_overlay;     /* Are we using an overlay surface */
     bool   restore_overlay;
 
     /* DDraw capabilities */
@@ -205,8 +212,6 @@ struct vout_display_sys_t
 
 #ifdef MODULE_NAME_IS_direct3d9
     bool allow_hw_yuv;    /* Should we use hardware YUV->RGB conversions */
-    /* show video on desktop window ? */
-    bool use_desktop;
     struct {
         bool is_fullscreen;
         bool is_on_top;
diff --git a/modules/video_output/win32/direct3d11.c b/modules/video_output/win32/direct3d11.c
index a4c8511..77e04ed 100644
--- a/modules/video_output/win32/direct3d11.c
+++ b/modules/video_output/win32/direct3d11.c
@@ -567,8 +567,8 @@ static int AllocateShaderView(vout_display_t *vd, const d3d_format_t *format, ID
 
 static picture_pool_t *Pool(vout_display_t *vd, unsigned pool_size)
 {
-    if ( vd->sys->pool != NULL )
-        return vd->sys->pool;
+    if ( vd->sys->sys.pool != NULL )
+        return vd->sys->sys.pool;
 
     if (pool_size > 30) {
         msg_Err(vd, "Avoid crashing when using ID3D11VideoDecoderOutputView with too many slices (%d)", pool_size);
@@ -654,10 +654,10 @@ static picture_pool_t *Pool(vout_display_t *vd, unsigned pool_size)
     pool_cfg.picture_count = pool_size;
     pool_cfg.picture       = pictures;
 
-    vd->sys->pool = picture_pool_NewExtended( &pool_cfg );
+    vd->sys->sys.pool = picture_pool_NewExtended( &pool_cfg );
 
 error:
-    if (vd->sys->pool ==NULL && pictures) {
+    if (vd->sys->sys.pool ==NULL && pictures) {
         msg_Dbg(vd, "Failed to create the picture d3d11 pool");
         for (unsigned i=0;i<picture_count; ++i)
             DestroyDisplayPoolPicture(pictures[i]);
@@ -668,10 +668,10 @@ error:
         memset( &pool_cfg, 0, sizeof( pool_cfg ) );
         pool_cfg.picture_count = 0;
 
-        vd->sys->pool = picture_pool_NewExtended( &pool_cfg );
+        vd->sys->sys.pool = picture_pool_NewExtended( &pool_cfg );
     }
 #endif
-    return vd->sys->pool;
+    return vd->sys->sys.pool;
 }
 
 #ifdef HAVE_ID3D11VIDEODECODER
@@ -710,8 +710,8 @@ static HRESULT UpdateBackBuffer(vout_display_t *vd)
     HRESULT hr;
     ID3D11Texture2D* pDepthStencil;
     ID3D11Texture2D* pBackBuffer;
-    uint32_t i_width  = RECTWidth(sys->rect_dest_clipped);
-    uint32_t i_height = RECTHeight(sys->rect_dest_clipped);
+    uint32_t i_width  = RECTWidth(sys->sys.rect_dest_clipped);
+    uint32_t i_height = RECTHeight(sys->sys.rect_dest_clipped);
 #if VLC_WINSTORE_APP
     UINT dataSize = sizeof(i_width);
     hr = IDXGISwapChain_GetPrivateData(sys->dxgiswapChain, &GUID_SWAPCHAIN_WIDTH, &dataSize, &i_width);
@@ -963,12 +963,12 @@ static int Control(vout_display_t *vd, int query, va_list args)
 static void Manage(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
-    RECT size_before = sys->rect_dest_clipped;
+    RECT size_before = sys->sys.rect_dest_clipped;
 
     CommonManage(vd);
 
-    if (RECTWidth(size_before)  != RECTWidth(sys->rect_dest_clipped) ||
-        RECTHeight(size_before) != RECTHeight(sys->rect_dest_clipped))
+    if (RECTWidth(size_before)  != RECTWidth(sys->sys.rect_dest_clipped) ||
+        RECTHeight(size_before) != RECTHeight(sys->sys.rect_dest_clipped))
     {
 #if defined(HAVE_ID3D11VIDEODECODER)
         if( sys->context_lock != INVALID_HANDLE_VALUE )
@@ -976,8 +976,8 @@ static void Manage(vout_display_t *vd)
             WaitForSingleObjectEx( sys->context_lock, INFINITE, FALSE );
         }
 #endif
-        msg_Dbg(vd, "Manage detected size change %dx%d", RECTWidth(sys->rect_dest_clipped),
-                RECTHeight(sys->rect_dest_clipped));
+        msg_Dbg(vd, "Manage detected size change %dx%d", RECTWidth(sys->sys.rect_dest_clipped),
+                RECTHeight(sys->sys.rect_dest_clipped));
 
         UpdateBackBuffer(vd);
 
@@ -1258,7 +1258,7 @@ static int Direct3D11Open(vout_display_t *vd, video_format_t *fmt)
     }
 
     hr = IDXGIFactory2_CreateSwapChainForHwnd(sys->dxgifactory, (IUnknown *)sys->d3ddevice,
-                                              sys->hvideownd, &scd, NULL, NULL, &sys->dxgiswapChain);
+                                              sys->sys.hvideownd, &scd, NULL, NULL, &sys->dxgiswapChain);
     IDXGIFactory2_Release(sys->dxgifactory);
     if (FAILED(hr)) {
        msg_Err(vd, "Could not create the SwapChain. (hr=0x%lX)", hr);
@@ -1352,7 +1352,7 @@ static int Direct3D11Open(vout_display_t *vd, video_format_t *fmt)
 #endif
 
 #if !VLC_WINSTORE_APP
-    EventThreadUpdateTitle(sys->event, VOUT_TITLE " (Direct3D11 output)");
+    EventThreadUpdateTitle(sys->sys.event, VOUT_TITLE " (Direct3D11 output)");
 #endif
 
     msg_Dbg(vd, "Direct3D11 device adapter successfully initialized");
@@ -1388,8 +1388,8 @@ static void UpdatePicQuadPosition(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
 
-    sys->picQuad.cropViewport.Width    = RECTWidth(sys->rect_dest_clipped);
-    sys->picQuad.cropViewport.Height   = RECTHeight(sys->rect_dest_clipped);
+    sys->picQuad.cropViewport.Width    = RECTWidth(sys->sys.rect_dest_clipped);
+    sys->picQuad.cropViewport.Height   = RECTHeight(sys->sys.rect_dest_clipped);
     sys->picQuad.cropViewport.TopLeftX = 0;
     sys->picQuad.cropViewport.TopLeftY = 0;
 
@@ -1680,8 +1680,8 @@ static int Direct3D11CreatePool(vout_display_t *vd, video_format_t *fmt)
     pool_cfg.lock          = Direct3D11MapTexture;
     //pool_cfg.unlock        = Direct3D11UnmapTexture;
 
-    sys->pool = picture_pool_NewExtended(&pool_cfg);
-    if (!sys->pool) {
+    sys->sys.pool = picture_pool_NewExtended(&pool_cfg);
+    if (!sys->sys.pool) {
         picture_Release(picture);
         return VLC_ENOMEM;
     }
@@ -1693,9 +1693,9 @@ static void Direct3D11DestroyPool(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
 
-    if (sys->pool)
-        picture_pool_Release(sys->pool);
-    sys->pool = NULL;
+    if (sys->sys.pool)
+        picture_pool_Release(sys->sys.pool);
+    sys->sys.pool = NULL;
 }
 
 static void SetupQuadFlat(d3d_vertex_t *dst_data, const video_format_t *fmt, WORD *triangle_pos)
@@ -2304,12 +2304,12 @@ static int Direct3D11MapSubpicture(vout_display_t *vd, int *subpicture_region_co
 
         d3d_quad_t *quad = (d3d_quad_t *) quad_picture->p_sys;
 
-        quad->cropViewport.Width =  (FLOAT) r->fmt.i_visible_width  * RECTWidth(sys->rect_dest)  / subpicture->i_original_picture_width;
-        quad->cropViewport.Height = (FLOAT) r->fmt.i_visible_height * RECTHeight(sys->rect_dest) / subpicture->i_original_picture_height;
+        quad->cropViewport.Width =  (FLOAT) r->fmt.i_visible_width  * RECTWidth(sys->sys.rect_dest)  / subpicture->i_original_picture_width;
+        quad->cropViewport.Height = (FLOAT) r->fmt.i_visible_height * RECTHeight(sys->sys.rect_dest) / subpicture->i_original_picture_height;
         quad->cropViewport.MinDepth = 0.0f;
         quad->cropViewport.MaxDepth = 1.0f;
-        quad->cropViewport.TopLeftX = sys->rect_dest.left + (FLOAT) r->i_x * RECTWidth(sys->rect_dest) / subpicture->i_original_picture_width;
-        quad->cropViewport.TopLeftY = sys->rect_dest.top  + (FLOAT) r->i_y * RECTHeight(sys->rect_dest) / subpicture->i_original_picture_height;
+        quad->cropViewport.TopLeftX = sys->sys.rect_dest.left + (FLOAT) r->i_x * RECTWidth(sys->sys.rect_dest) / subpicture->i_original_picture_width;
+        quad->cropViewport.TopLeftY = sys->sys.rect_dest.top  + (FLOAT) r->i_y * RECTHeight(sys->sys.rect_dest) / subpicture->i_original_picture_height;
 
         UpdateQuadOpacity(vd, quad, r->i_alpha / 255.0f );
     }
diff --git a/modules/video_output/win32/direct3d9.c b/modules/video_output/win32/direct3d9.c
index 25aef91..0908d71 100644
--- a/modules/video_output/win32/direct3d9.c
+++ b/modules/video_output/win32/direct3d9.c
@@ -190,7 +190,7 @@ static int Open(vlc_object_t *object)
         return VLC_EGENERIC;
     }
 
-    sys->use_desktop = var_CreateGetBool(vd, "video-wallpaper");
+    sys->sys.use_desktop = var_CreateGetBool(vd, "video-wallpaper");
     sys->reset_device = false;
     sys->reopen_device = false;
     sys->lost_not_ready = false;
@@ -232,7 +232,7 @@ static int Open(vlc_object_t *object)
     /* Interaction */
     vlc_mutex_init(&sys->lock);
     sys->ch_desktop = false;
-    sys->desktop_requested = sys->use_desktop;
+    sys->desktop_requested = sys->sys.use_desktop;
 
     vlc_value_t val;
     val.psz_string = _("Desktop");
@@ -251,7 +251,7 @@ static int Open(vlc_object_t *object)
     vd->manage  = Manage;
 
     /* Fix state in case of desktop mode */
-    if (sys->use_desktop && vd->cfg->is_fullscreen)
+    if (sys->sys.use_desktop && vd->cfg->is_fullscreen)
         vout_display_SendEventFullscreen(vd, false);
 
     return VLC_SUCCESS;
@@ -293,8 +293,8 @@ static void DestroyPicture(picture_t *picture)
 /* */
 static picture_pool_t *Pool(vout_display_t *vd, unsigned count)
 {
-    if ( vd->sys->pool != NULL )
-        return vd->sys->pool;
+    if ( vd->sys->sys.pool != NULL )
+        return vd->sys->sys.pool;
 
     picture_t**       pictures = NULL;
     unsigned          picture_count = 0;
@@ -341,15 +341,15 @@ static picture_pool_t *Pool(vout_display_t *vd, unsigned count)
     pool_cfg.picture_count = count;
     pool_cfg.picture       = pictures;
 
-    vd->sys->pool = picture_pool_NewExtended( &pool_cfg );
+    vd->sys->sys.pool = picture_pool_NewExtended( &pool_cfg );
 
 error:
-    if (vd->sys->pool == NULL && pictures) {
+    if (vd->sys->sys.pool == NULL && pictures) {
         for (unsigned i=0;i<picture_count; ++i)
             DestroyPicture(pictures[i]);
     }
     free(pictures);
-    return vd->sys->pool;
+    return vd->sys->sys.pool;
 }
 
 static int  Direct3D9LockSurface(picture_t *);
@@ -415,8 +415,8 @@ static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
 
     // Present the back buffer contents to the display
     // No stretching should happen here !
-    const RECT src = sys->rect_dest_clipped;
-    const RECT dst = sys->rect_dest_clipped;
+    const RECT src = sys->sys.rect_dest_clipped;
+    const RECT dst = sys->sys.rect_dest_clipped;
 
     HRESULT hr;
     if (sys->use_d3d9ex) {
@@ -447,31 +447,31 @@ static int ControlReopenDevice(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
 
-    if (!sys->use_desktop) {
+    if (!sys->sys.use_desktop) {
         /* Save non-desktop state */
         sys->desktop_save.is_fullscreen = vd->cfg->is_fullscreen;
-        sys->desktop_save.is_on_top     = sys->is_on_top;
+        sys->desktop_save.is_on_top     = sys->sys.is_on_top;
 
         WINDOWPLACEMENT wp = { .length = sizeof(wp), };
-        GetWindowPlacement(sys->hparent ? sys->hparent : sys->hwnd, &wp);
+        GetWindowPlacement(sys->sys.hparent ? sys->sys.hparent : sys->sys.hwnd, &wp);
         sys->desktop_save.win = wp.rcNormalPosition;
     }
 
     /* */
     Direct3D9Close(vd);
-    EventThreadStop(sys->event);
+    EventThreadStop(sys->sys.event);
 
     /* */
     vlc_mutex_lock(&sys->lock);
-    sys->use_desktop = sys->desktop_requested;
+    sys->sys.use_desktop = sys->desktop_requested;
     sys->ch_desktop = false;
     vlc_mutex_unlock(&sys->lock);
 
     /* */
     event_cfg_t cfg;
     memset(&cfg, 0, sizeof(cfg));
-    cfg.use_desktop = sys->use_desktop;
-    if (!sys->use_desktop) {
+    cfg.use_desktop = sys->sys.use_desktop;
+    if (!sys->sys.use_desktop) {
         cfg.x      = sys->desktop_save.win.left;
         cfg.y      = sys->desktop_save.win.top;
         cfg.width  = sys->desktop_save.win.right  - sys->desktop_save.win.left;
@@ -479,16 +479,16 @@ static int ControlReopenDevice(vout_display_t *vd)
     }
 
     event_hwnd_t hwnd;
-    if (EventThreadStart(sys->event, &hwnd, &cfg)) {
+    if (EventThreadStart(sys->sys.event, &hwnd, &cfg)) {
         msg_Err(vd, "Failed to restart event thread");
         return VLC_EGENERIC;
     }
-    sys->parent_window = hwnd.parent_window;
-    sys->hparent       = hwnd.hparent;
-    sys->hwnd          = hwnd.hwnd;
-    sys->hvideownd     = hwnd.hvideownd;
-    sys->hfswnd        = hwnd.hfswnd;
-    SetRectEmpty(&sys->rect_parent);
+    sys->sys.parent_window = hwnd.parent_window;
+    sys->sys.hparent       = hwnd.hparent;
+    sys->sys.hwnd          = hwnd.hwnd;
+    sys->sys.hvideownd     = hwnd.hvideownd;
+    sys->sys.hfswnd        = hwnd.hfswnd;
+    SetRectEmpty(&sys->sys.rect_parent);
 
     /* */
     video_format_t fmt;
@@ -498,9 +498,9 @@ static int ControlReopenDevice(vout_display_t *vd)
         return VLC_EGENERIC;
     }
     vd->fmt = fmt;
-    sys->is_first_display = true;
+    sys->sys.is_first_display = true;
 
-    if (sys->use_desktop) {
+    if (sys->sys.use_desktop) {
         /* Disable fullscreen/on_top while using desktop */
         if (sys->desktop_save.is_fullscreen)
             vout_display_SendEventFullscreen(vd, false);
@@ -558,12 +558,12 @@ static void Manage (vout_display_t *vd)
     }
 
     /* Position Change */
-    if (sys->changes & DX_POSITION_CHANGE) {
+    if (sys->sys.changes & DX_POSITION_CHANGE) {
 #if 0 /* need that when bicubic filter is available */
         RECT rect;
         UINT width, height;
 
-        GetClientRect(p_sys->hvideownd, &rect);
+        GetClientRect(p_sys->sys.hvideownd, &rect);
         width  = rect.right-rect.left;
         height = rect.bottom-rect.top;
 
@@ -576,7 +576,7 @@ static void Manage (vout_display_t *vd)
         }
 #endif
         sys->clear_scene = true;
-        sys->changes &= ~DX_POSITION_CHANGE;
+        sys->sys.changes &= ~DX_POSITION_CHANGE;
     }
 }
 
@@ -719,7 +719,7 @@ static int Direct3D9FillPresentationParameters(vout_display_t *vd)
     ZeroMemory(d3dpp, sizeof(D3DPRESENT_PARAMETERS));
     d3dpp->Flags                  = D3DPRESENTFLAG_VIDEO;
     d3dpp->Windowed               = TRUE;
-    d3dpp->hDeviceWindow          = vd->sys->hvideownd;
+    d3dpp->hDeviceWindow          = vd->sys->sys.hvideownd;
     d3dpp->BackBufferWidth        = __MAX((unsigned int)GetSystemMetrics(SM_CXVIRTUALSCREEN),
                                           d3ddm.Width);
     d3dpp->BackBufferHeight       = __MAX((unsigned int)GetSystemMetrics(SM_CYVIRTUALSCREEN),
@@ -732,7 +732,7 @@ static int Direct3D9FillPresentationParameters(vout_display_t *vd)
     d3dpp->EnableAutoDepthStencil = FALSE;
 
     /* */
-    RECT *display = &vd->sys->rect_display;
+    RECT *display = &vd->sys->sys.rect_display;
     display->left   = 0;
     display->top    = 0;
     display->right  = d3dpp->BackBufferWidth;
@@ -788,7 +788,7 @@ static int Direct3D9Open(vout_display_t *vd, video_format_t *fmt)
     if (sys->use_d3d9ex) {
         LPDIRECT3DDEVICE9EX d3ddevex;
         hr = IDirect3D9Ex_CreateDeviceEx((LPDIRECT3D9EX)d3dobj, AdapterToUse,
-                                         DeviceType, sys->hvideownd,
+                                         DeviceType, sys->sys.hvideownd,
                                          D3DCREATE_SOFTWARE_VERTEXPROCESSING|
                                          D3DCREATE_MULTITHREADED,
                                          &sys->d3dpp, NULL, &d3ddevex);
@@ -796,7 +796,7 @@ static int Direct3D9Open(vout_display_t *vd, video_format_t *fmt)
     } else {
         LPDIRECT3DDEVICE9 d3ddev;
         hr = IDirect3D9_CreateDevice(d3dobj, AdapterToUse,
-                                     DeviceType, sys->hvideownd,
+                                     DeviceType, sys->sys.hvideownd,
                                      D3DCREATE_SOFTWARE_VERTEXPROCESSING|
                                      D3DCREATE_MULTITHREADED,
                                      &sys->d3dpp, &d3ddev);
@@ -816,7 +816,7 @@ static int Direct3D9Open(vout_display_t *vd, video_format_t *fmt)
     }
 
     /* Change the window title bar text */
-    EventThreadUpdateTitle(sys->event, VOUT_TITLE " (Direct3D9 output)");
+    EventThreadUpdateTitle(sys->sys.event, VOUT_TITLE " (Direct3D9 output)");
 
     msg_Dbg(vd, "Direct3D9 device adapter successfully initialized");
     return VLC_SUCCESS;
@@ -1147,8 +1147,8 @@ static int Direct3D9CreatePool(vout_display_t *vd, video_format_t *fmt)
     pool_cfg.lock          = Direct3D9LockSurface;
     pool_cfg.unlock        = Direct3D9UnlockSurface;
 
-    sys->pool = picture_pool_NewExtended(&pool_cfg);
-    if (!sys->pool) {
+    sys->sys.pool = picture_pool_NewExtended(&pool_cfg);
+    if (!sys->sys.pool) {
         picture_Release(picture);
         IDirect3DSurface9_Release(surface);
         return VLC_ENOMEM;
@@ -1162,16 +1162,16 @@ static void Direct3D9DestroyPool(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
 
-    if (sys->pool) {
+    if (sys->sys.pool) {
         picture_sys_t *picsys = sys->picsys;
         if ( picsys != NULL ) {
             IDirect3DSurface9_Release(picsys->surface);
             if (picsys->fallback)
                 picture_Release(picsys->fallback);
         }
-        picture_pool_Release(sys->pool);
+        picture_pool_Release(sys->sys.pool);
     }
-    sys->pool = NULL;
+    sys->sys.pool = NULL;
 }
 
 /**
@@ -1604,7 +1604,7 @@ static int Direct3D9ImportPicture(vout_display_t *vd,
 
     /* Copy picture surface into texture surface
      * color space conversion happen here */
-    hr = IDirect3DDevice9_StretchRect(sys->d3ddev, source, &vd->sys->rect_src_clipped, destination, NULL, D3DTEXF_NONE );
+    hr = IDirect3DDevice9_StretchRect(sys->d3ddev, source, &vd->sys->sys.rect_src_clipped, destination, NULL, D3DTEXF_NONE );
     IDirect3DSurface9_Release(destination);
     if (FAILED(hr)) {
         msg_Dbg(vd, "Failed IDirect3DDevice9_StretchRect: source 0x%p 0x%0lx",
@@ -1614,7 +1614,7 @@ static int Direct3D9ImportPicture(vout_display_t *vd,
 
     /* */
     region->texture = sys->d3dtex;
-    Direct3D9SetupVertices(region->vertex, &vd->sys->rect_dest_clipped, 255, vd->fmt.orientation);
+    Direct3D9SetupVertices(region->vertex, &vd->sys->sys.rect_dest_clipped, 255, vd->fmt.orientation);
     return VLC_SUCCESS;
 }
 
@@ -1721,8 +1721,8 @@ static void Direct3D9ImportSubpicture(vout_display_t *vd,
             msg_Err(vd, "Failed to lock the texture");
         }
 
-        /* Map the subpicture to sys->rect_dest */
-        const RECT video = sys->rect_dest;
+        /* Map the subpicture to sys->sys.rect_dest */
+        const RECT video = sys->sys.rect_dest;
         const float scale_w = (float)(video.right  - video.left) / subpicture->i_original_picture_width;
         const float scale_h = (float)(video.bottom - video.top)  / subpicture->i_original_picture_height;
 
diff --git a/modules/video_output/win32/directdraw.c b/modules/video_output/win32/directdraw.c
index f65162c..3f7cff6 100644
--- a/modules/video_output/win32/directdraw.c
+++ b/modules/video_output/win32/directdraw.c
@@ -182,7 +182,7 @@ static int Open(vlc_object_t *object)
     /* */
     sys->use_wallpaper = var_CreateGetBool(vd, "video-wallpaper");
     /* FIXME */
-    sys->use_overlay = false;//var_CreateGetBool(vd, "overlay"); /* FIXME */
+    sys->sys.use_overlay = false;//var_CreateGetBool(vd, "overlay"); /* FIXME */
     sys->restore_overlay = false;
     var_Create(vd, "directx-device", VLC_VAR_STRING | VLC_VAR_DOINHERIT);
 
@@ -260,7 +260,7 @@ static void Close(vlc_object_t *object)
 static picture_pool_t *Pool(vout_display_t *vd, unsigned count)
 {
     VLC_UNUSED(count);
-    return vd->sys->pool;
+    return vd->sys->sys.pool;
 }
 static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpicture)
 {
@@ -272,7 +272,7 @@ static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
      * and restore it if need be */
     if (IDirectDrawSurface2_IsLost(sys->display) == DDERR_SURFACELOST) {
         if (IDirectDrawSurface2_Restore(sys->display) == DD_OK) {
-            if (sys->use_overlay)
+            if (sys->sys.use_overlay)
                 DirectXUpdateOverlay(vd, NULL);
         }
     }
@@ -282,7 +282,7 @@ static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
     /* */
     DirectXUnlock(picture);
 
-    if (sys->use_overlay) {
+    if (sys->sys.use_overlay) {
         /* Flip the overlay buffers if we are using back buffers */
         if (picture->p_sys->surface != picture->p_sys->front_surface) {
             HRESULT hr = IDirectDrawSurface2_Flip(picture->p_sys->front_surface,
@@ -298,22 +298,22 @@ static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
         ddbltfx.dwDDFX = DDBLTFX_NOTEARING;
 
         HRESULT hr = IDirectDrawSurface2_Blt(sys->display,
-                                             &sys->rect_dest_clipped,
+                                             &sys->sys.rect_dest_clipped,
                                              picture->p_sys->surface,
-                                             &sys->rect_src_clipped,
+                                             &sys->sys.rect_src_clipped,
                                              DDBLT_ASYNC, &ddbltfx);
         if (hr != DD_OK)
             msg_Warn(vd, "could not blit surface (error %li)", hr);
     }
     DirectXLock(picture);
 
-    if (sys->is_first_display) {
+    if (sys->sys.is_first_display) {
         IDirectDraw_WaitForVerticalBlank(sys->ddobject,
                                          DDWAITVB_BLOCKBEGIN, NULL);
-        if (sys->use_overlay) {
+        if (sys->sys.use_overlay) {
             HBRUSH brush = CreateSolidBrush(sys->i_rgb_colorkey);
             /* set the colorkey as the backgound brush for the video window */
-            SetClassLongPtr(sys->hvideownd, GCLP_HBRBACKGROUND, (LONG_PTR)brush);
+            SetClassLongPtr(sys->sys.hvideownd, GCLP_HBRBACKGROUND, (LONG_PTR)brush);
         }
     }
     CommonDisplay(vd);
@@ -350,18 +350,18 @@ static void Manage(vout_display_t *vd)
 
     CommonManage(vd);
 
-    if (sys->changes & DX_POSITION_CHANGE) {
+    if (sys->sys.changes & DX_POSITION_CHANGE) {
         /* Update overlay */
-        if (sys->use_overlay)
+        if (sys->sys.use_overlay)
             DirectXUpdateOverlay(vd, NULL);
 
         /* Check if we are still on the same monitor */
-        HMONITOR hmon = MonitorFromWindow(sys->hwnd, MONITOR_DEFAULTTONEAREST);
+        HMONITOR hmon = MonitorFromWindow(sys->sys.hwnd, MONITOR_DEFAULTTONEAREST);
         if (sys->hmonitor != hmon) {
             vout_display_SendEventPicturesInvalid(vd);
         }
         /* */
-        sys->changes &= ~DX_POSITION_CHANGE;
+        sys->sys.changes &= ~DX_POSITION_CHANGE;
     }
 
     /* Wallpaper mode change */
@@ -411,25 +411,25 @@ static int DirectXOpen(vout_display_t *vd, video_format_t *fmt)
     UpdateRects(vd, NULL, NULL, true);
 
     /* Create the picture pool */
-    if (DirectXCreatePool(vd, &sys->use_overlay, fmt)) {
+    if (DirectXCreatePool(vd, &sys->sys.use_overlay, fmt)) {
         msg_Err(vd, "cannot create any DirectX surface");
         return VLC_EGENERIC;
     }
 
     /* */
-    if (sys->use_overlay)
+    if (sys->sys.use_overlay)
         DirectXUpdateOverlay(vd, NULL);
-    EventThreadUseOverlay(sys->event, sys->use_overlay);
+    EventThreadUseOverlay(sys->sys.event, sys->sys.use_overlay);
 
     /* Change the window title bar text */
     const char *fallback;
-    if (sys->use_overlay)
+    if (sys->sys.use_overlay)
         fallback = VOUT_TITLE " (hardware YUV overlay DirectX output)";
     else if (vlc_fourcc_IsYUV(fmt->i_chroma))
         fallback = VOUT_TITLE " (hardware YUV DirectX output)";
     else
         fallback = VOUT_TITLE " (software RGB DirectX output)";
-    EventThreadUpdateTitle(sys->event, fallback);
+    EventThreadUpdateTitle(sys->sys.event, fallback);
 
     return VLC_SUCCESS;
 }
@@ -472,13 +472,13 @@ static BOOL WINAPI DirectXOpenDDrawCallback(GUID *guid, LPSTR desc,
             RECT rect;
 
             /* Move window to the right screen */
-            GetWindowRect(sys->hwnd, &rect);
+            GetWindowRect(sys->sys.hwnd, &rect);
             if (!IntersectRect(&rect, &rect, &monitor_info.rcWork)) {
                 rect.left = monitor_info.rcWork.left;
                 rect.top = monitor_info.rcWork.top;
                 msg_Dbg(vd, "DirectXEnumCallback: setting window "
                             "position to %ld,%ld", rect.left, rect.top);
-                SetWindowPos(sys->hwnd, NULL,
+                SetWindowPos(sys->sys.hwnd, NULL,
                              rect.left, rect.top, 0, 0,
                              SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
             }
@@ -548,21 +548,21 @@ static void DirectXGetDDrawCaps(vout_display_t *vd)
 
     if (align_boundary_src || align_boundary_dest || align_size_src || align_size_dest) {
         if (align_boundary_src)
-            vd->sys->i_align_src_boundary = ddcaps.dwAlignBoundarySrc;
+            vd->sys->sys.i_align_src_boundary = ddcaps.dwAlignBoundarySrc;
         if (align_boundary_dest)
-            vd->sys->i_align_dest_boundary = ddcaps.dwAlignBoundaryDest;
+            vd->sys->sys.i_align_dest_boundary = ddcaps.dwAlignBoundaryDest;
         if (align_size_src)
-            vd->sys->i_align_src_size = ddcaps.dwAlignSizeSrc;
+            vd->sys->sys.i_align_src_size = ddcaps.dwAlignSizeSrc;
         if (align_size_dest)
-            vd->sys->i_align_dest_size = ddcaps.dwAlignSizeDest;
+            vd->sys->sys.i_align_dest_size = ddcaps.dwAlignSizeDest;
 
         msg_Dbg(vd,
                 "align_boundary_src=%i,%i align_boundary_dest=%i,%i "
                 "align_size_src=%i,%i align_size_dest=%i,%i",
-                align_boundary_src,  vd->sys->i_align_src_boundary,
-                align_boundary_dest, vd->sys->i_align_dest_boundary,
-                align_size_src,  vd->sys->i_align_src_size,
-                align_size_dest, vd->sys->i_align_dest_size);
+                align_boundary_src,  vd->sys->sys.i_align_src_boundary,
+                align_boundary_dest, vd->sys->sys.i_align_dest_boundary,
+                align_size_src,  vd->sys->sys.i_align_src_size,
+                align_size_dest, vd->sys->sys.i_align_dest_size);
     }
 }
 
@@ -595,7 +595,7 @@ static int DirectXOpenDDraw(vout_display_t *vd)
             free(device);
         }
 
-        sys->hmonitor = MonitorFromWindow(sys->hwnd, MONITOR_DEFAULTTONEAREST);
+        sys->hmonitor = MonitorFromWindow(sys->sys.hwnd, MONITOR_DEFAULTTONEAREST);
 
         /* Enumerate displays */
         OurDirectDrawEnumerateEx(DirectXOpenDDrawCallback,
@@ -637,19 +637,19 @@ static int DirectXOpenDDraw(vout_display_t *vd)
         MONITORINFO monitor_info;
         monitor_info.cbSize = sizeof(MONITORINFO);
         GetMonitorInfoA(vd->sys->hmonitor, &monitor_info);
-        sys->rect_display = monitor_info.rcMonitor;
+        sys->sys.rect_display = monitor_info.rcMonitor;
     } else {
-        sys->rect_display.left   = 0;
-        sys->rect_display.top    = 0;
-        sys->rect_display.right  = GetSystemMetrics(SM_CXSCREEN);
-        sys->rect_display.bottom = GetSystemMetrics(SM_CYSCREEN);
+        sys->sys.rect_display.left   = 0;
+        sys->sys.rect_display.top    = 0;
+        sys->sys.rect_display.right  = GetSystemMetrics(SM_CXSCREEN);
+        sys->sys.rect_display.bottom = GetSystemMetrics(SM_CYSCREEN);
     }
 
     msg_Dbg(vd, "screen dimensions (%lix%li,%lix%li)",
-            sys->rect_display.left,
-            sys->rect_display.top,
-            sys->rect_display.right,
-            sys->rect_display.bottom);
+            sys->sys.rect_display.left,
+            sys->sys.rect_display.top,
+            sys->sys.rect_display.right,
+            sys->sys.rect_display.bottom);
 
     /* Probe the capabilities of the hardware */
     DirectXGetDDrawCaps(vd);
@@ -691,7 +691,7 @@ static void DirectXCreateClipper(vout_display_t *vd)
     }
 
     /* Associate the clipper to the window */
-    hr = IDirectDrawClipper_SetHWnd(sys->clipper, 0, sys->hvideownd);
+    hr = IDirectDrawClipper_SetHWnd(sys->clipper, 0, sys->sys.hvideownd);
     if (hr != DD_OK) {
         msg_Warn(vd, "cannot attach clipper to window (error %li)", hr);
         goto error;
@@ -1280,8 +1280,8 @@ static int DirectXCreatePool(vout_display_t *vd,
     cfg.lock          = DirectXLock;
     cfg.unlock        = DirectXUnlock;
 
-    sys->pool = picture_pool_NewExtended(&cfg);
-    if (!sys->pool) {
+    sys->sys.pool = picture_pool_NewExtended(&cfg);
+    if (!sys->sys.pool) {
         picture_Release(picture);
         DirectXDestroyPictureResource(vd);
         return VLC_ENOMEM;
@@ -1292,11 +1292,11 @@ static void DirectXDestroyPool(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
 
-    if (sys->pool) {
+    if (sys->sys.pool) {
         DirectXDestroyPictureResource(vd);
-        picture_pool_Release(sys->pool);
+        picture_pool_Release(sys->sys.pool);
     }
-    sys->pool = NULL;
+    sys->sys.pool = NULL;
 }
 
 /**
@@ -1310,32 +1310,32 @@ static int DirectXUpdateOverlay(vout_display_t *vd, LPDIRECTDRAWSURFACE2 surface
 {
     vout_display_sys_t *sys = vd->sys;
 
-    RECT src = sys->rect_src_clipped;
-    RECT dst = sys->rect_dest_clipped;
+    RECT src = sys->sys.rect_src_clipped;
+    RECT dst = sys->sys.rect_dest_clipped;
 
     if (sys->use_wallpaper) {
         src.left   = vd->source.i_x_offset;
         src.top    = vd->source.i_y_offset;
         src.right  = vd->source.i_x_offset + vd->source.i_visible_width;
         src.bottom = vd->source.i_y_offset + vd->source.i_visible_height;
-        AlignRect(&src, sys->i_align_src_boundary, sys->i_align_src_size);
+        AlignRect(&src, sys->sys.i_align_src_boundary, sys->sys.i_align_src_size);
 
         vout_display_cfg_t cfg = *vd->cfg;
-        cfg.display.width  = sys->rect_display.right;
-        cfg.display.height = sys->rect_display.bottom;
+        cfg.display.width  = sys->sys.rect_display.right;
+        cfg.display.height = sys->sys.rect_display.bottom;
 
         vout_display_place_t place;
         vout_display_PlacePicture(&place, &vd->source, &cfg, true);
 
-        dst.left   = sys->rect_display.left + place.x;
-        dst.top    = sys->rect_display.top  + place.y;
+        dst.left   = sys->sys.rect_display.left + place.x;
+        dst.top    = sys->sys.rect_display.top  + place.y;
         dst.right  = dst.left + place.width;
         dst.bottom = dst.top  + place.height;
-        AlignRect(&dst, sys->i_align_dest_boundary, sys->i_align_dest_size);
+        AlignRect(&dst, sys->sys.i_align_dest_boundary, sys->sys.i_align_dest_size);
     }
 
     if (!surface) {
-        if (!sys->pool)
+        if (!sys->sys.pool)
             return VLC_EGENERIC;
         surface = sys->picsys->front_surface;
     }
@@ -1400,7 +1400,7 @@ static void WallpaperChange(vout_display_t *vd, bool use_wallpaper)
     InvalidateRect(hwnd, NULL, TRUE);
     UpdateWindow(hwnd);
 
-    if (sys->use_overlay)
+    if (sys->sys.use_overlay)
       DirectXUpdateOverlay(vd, NULL);
 }
 
diff --git a/modules/video_output/win32/events.c b/modules/video_output/win32/events.c
index c8003c3..23e2eb7 100644
--- a/modules/video_output/win32/events.c
+++ b/modules/video_output/win32/events.c
@@ -1020,7 +1020,7 @@ static long FAR PASCAL WinVoutEventProc( HWND hwnd, UINT message,
         case IDM_TOGGLE_ON_TOP:            /* toggle the "on top" status */
         {
             msg_Dbg(vd, "WinProc WM_SYSCOMMAND: IDM_TOGGLE_ON_TOP");
-            HMENU hMenu = GetSystemMenu(vd->sys->hwnd, FALSE);
+            HMENU hMenu = GetSystemMenu(vd->sys->sys.hwnd, FALSE);
             vout_display_SendWindowState(vd, (GetMenuState(hMenu, IDM_TOGGLE_ON_TOP, MF_BYCOMMAND) & MF_CHECKED) ?
                     VOUT_WINDOW_STATE_NORMAL : VOUT_WINDOW_STATE_ABOVE);
             return 0;
diff --git a/modules/video_output/win32/glwin32.c b/modules/video_output/win32/glwin32.c
index fd1dc36..4b4e437 100644
--- a/modules/video_output/win32/glwin32.c
+++ b/modules/video_output/win32/glwin32.c
@@ -81,7 +81,7 @@ static void CreateGPUAffinityDC(vout_display_t *vd, UINT nVidiaAffinity) {
     pfd.iLayerType = PFD_MAIN_PLANE;
 
     /* create a temporary GL context */
-    HDC winDC = GetDC(vd->sys->hvideownd);
+    HDC winDC = GetDC(vd->sys->sys.hvideownd);
     SetPixelFormat(winDC, ChoosePixelFormat(winDC, &pfd), &pfd);
     HGLRC hGLRC = wglCreateContext(winDC);
     wglMakeCurrent(winDC, hGLRC);
@@ -129,7 +129,7 @@ static void DestroyGPUAffinityDC(vout_display_t *vd) {
     pfd.iLayerType = PFD_MAIN_PLANE;
 
     /* create a temporary GL context */
-    HDC winDC = GetDC(vd->sys->hvideownd);
+    HDC winDC = GetDC(vd->sys->sys.hvideownd);
     SetPixelFormat(winDC, ChoosePixelFormat(winDC, &pfd), &pfd);
     HGLRC hGLRC = wglCreateContext(winDC);
     wglMakeCurrent(winDC, hGLRC);
@@ -175,14 +175,14 @@ static int Open(vlc_object_t *object)
     if (CommonInit(vd))
         goto error;
 
-    EventThreadUpdateTitle(sys->event, VOUT_TITLE " (OpenGL output)");
+    EventThreadUpdateTitle(sys->sys.event, VOUT_TITLE " (OpenGL output)");
 
     /* process selected GPU affinity */
     int nVidiaAffinity = var_InheritInteger(vd, "gpu-affinity");
     if (nVidiaAffinity >= 0) CreateGPUAffinityDC(vd, nVidiaAffinity);
 
     /* */
-    sys->hGLDC = GetDC(sys->hvideownd);
+    sys->hGLDC = GetDC(sys->sys.hvideownd);
 
     /* Set the pixel format for the DC */
     PIXELFORMATDESCRIPTOR pfd;
@@ -272,7 +272,7 @@ static void Close(vlc_object_t *object)
     if (sys->hGLRC)
         wglDeleteContext(sys->hGLRC);
     if (sys->hGLDC)
-        ReleaseDC(sys->hvideownd, sys->hGLDC);
+        ReleaseDC(sys->sys.hvideownd, sys->hGLDC);
     DestroyGPUAffinityDC(vd);
 
     CommonClean(vd);
@@ -285,9 +285,9 @@ static picture_pool_t *Pool(vout_display_t *vd, unsigned count)
 {
     vout_display_sys_t *sys = vd->sys;
 
-    if (!sys->pool)
-        sys->pool = vout_display_opengl_GetPool(sys->vgl, count);
-    return sys->pool;
+    if (!sys->sys.pool)
+        sys->sys.pool = vout_display_opengl_GetPool(sys->vgl, count);
+    return sys->sys.pool;
 }
 
 static void Prepare(vout_display_t *vd, picture_t *picture, subpicture_t *subpicture)
@@ -316,8 +316,8 @@ static void Manage (vout_display_t *vd)
 
     CommonManage(vd);
 
-    const int width  = sys->rect_dest.right  - sys->rect_dest.left;
-    const int height = sys->rect_dest.bottom - sys->rect_dest.top;
+    const int width  = sys->sys.rect_dest.right  - sys->sys.rect_dest.left;
+    const int height = sys->sys.rect_dest.bottom - sys->sys.rect_dest.top;
     vout_display_opengl_SetWindowAspectRatio(sys->vgl, (float)width / height);
     glViewport(0, 0, width, height);
 }
diff --git a/modules/video_output/win32/wgl.c b/modules/video_output/win32/wgl.c
index 95a67b6..8d47612 100644
--- a/modules/video_output/win32/wgl.c
+++ b/modules/video_output/win32/wgl.c
@@ -79,7 +79,7 @@ static void CreateGPUAffinityDC(vlc_gl_t *gl, UINT nVidiaAffinity) {
     pfd.iLayerType = PFD_MAIN_PLANE;
 
     /* create a temporary GL context */
-    HDC winDC = GetDC(sys->hvideownd);
+    HDC winDC = GetDC(sys->sys.hvideownd);
     SetPixelFormat(winDC, ChoosePixelFormat(winDC, &pfd), &pfd);
     HGLRC hGLRC = wglCreateContext(winDC);
     wglMakeCurrent(winDC, hGLRC);
@@ -128,7 +128,7 @@ static void DestroyGPUAffinityDC(vlc_gl_t *gl) {
     pfd.iLayerType = PFD_MAIN_PLANE;
 
     /* create a temporary GL context */
-    HDC winDC = GetDC(sys->hvideownd);
+    HDC winDC = GetDC(sys->sys.hvideownd);
     SetPixelFormat(winDC, ChoosePixelFormat(winDC, &pfd), &pfd);
     HGLRC hGLRC = wglCreateContext(winDC);
     wglMakeCurrent(winDC, hGLRC);
@@ -161,7 +161,7 @@ static int Open(vlc_object_t *object)
     if (nVidiaAffinity >= 0) CreateGPUAffinityDC(gl, nVidiaAffinity);
 
     vout_window_t *wnd = gl->surface;
-    sys->hvideownd = wnd->handle.hwnd;
+    sys->sys.hvideownd = wnd->handle.hwnd;
     if (wnd->type != VOUT_WINDOW_TYPE_HWND)
         goto error;
 
@@ -225,7 +225,7 @@ static void Close(vlc_object_t *object)
     if (sys->hGLRC)
         wglDeleteContext(sys->hGLRC);
     if (sys->hGLDC)
-        ReleaseDC(sys->hvideownd, sys->hGLDC);
+        ReleaseDC(sys->sys.hvideownd, sys->hGLDC);
 
     DestroyGPUAffinityDC(gl);
 
diff --git a/modules/video_output/win32/wingdi.c b/modules/video_output/win32/wingdi.c
index ea4b237..b496603 100644
--- a/modules/video_output/win32/wingdi.c
+++ b/modules/video_output/win32/wingdi.c
@@ -122,7 +122,7 @@ static void Close(vlc_object_t *object)
 static picture_pool_t *Pool(vout_display_t *vd, unsigned count)
 {
     VLC_UNUSED(count);
-    return vd->sys->pool;
+    return vd->sys->sys.pool;
 }
 
 static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpicture)
@@ -130,11 +130,11 @@ static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
     vout_display_sys_t *sys = vd->sys;
 
 #define rect_src vd->sys->rect_src
-#define rect_src_clipped vd->sys->rect_src_clipped
-#define rect_dest vd->sys->rect_dest
-#define rect_dest_clipped vd->sys->rect_dest_clipped
+#define rect_src_clipped vd->sys->sys.rect_src_clipped
+#define rect_dest vd->sys->sys.rect_dest
+#define rect_dest_clipped vd->sys->sys.rect_dest_clipped
     RECT rect_dst = rect_dest_clipped;
-    HDC hdc = GetDC(sys->hvideownd);
+    HDC hdc = GetDC(sys->sys.hvideownd);
 
     OffsetRect(&rect_dst, -rect_dest.left, -rect_dest.top);
     SelectObject(sys->off_dc, sys->off_bitmap);
@@ -157,7 +157,7 @@ static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
                SRCCOPY);
     }
 
-    ReleaseDC(sys->hvideownd, hdc);
+    ReleaseDC(sys->sys.hvideownd, hdc);
 #undef rect_src
 #undef rect_src_clipped
 #undef rect_dest
@@ -192,7 +192,7 @@ static int Init(vout_display_t *vd,
     vout_display_sys_t *sys = vd->sys;
 
     /* */
-    RECT *display = &sys->rect_display;
+    RECT *display = &sys->sys.rect_display;
     display->left   = 0;
     display->top    = 0;
     display->right  = GetSystemMetrics(SM_CXSCREEN);;
@@ -201,7 +201,7 @@ static int Init(vout_display_t *vd,
     /* Initialize an offscreen bitmap for direct buffer operations. */
 
     /* */
-    HDC window_dc = GetDC(sys->hvideownd);
+    HDC window_dc = GetDC(sys->sys.hvideownd);
 
     /* */
     sys->i_depth = GetDeviceCaps(window_dc, PLANES) *
@@ -278,9 +278,9 @@ static int Init(vout_display_t *vd,
     sys->off_dc = CreateCompatibleDC(window_dc);
 
     SelectObject(sys->off_dc, sys->off_bitmap);
-    ReleaseDC(sys->hvideownd, window_dc);
+    ReleaseDC(sys->sys.hvideownd, window_dc);
 
-    EventThreadUpdateTitle(sys->event, VOUT_TITLE " (WinGDI output)");
+    EventThreadUpdateTitle(sys->sys.event, VOUT_TITLE " (WinGDI output)");
 
     /* */
     picture_resource_t rsc;
@@ -291,9 +291,9 @@ static int Init(vout_display_t *vd,
 
     picture_t *picture = picture_NewFromResource(fmt, &rsc);
     if (picture != NULL)
-        sys->pool = picture_pool_New(1, &picture);
+        sys->sys.pool = picture_pool_New(1, &picture);
     else
-        sys->pool = NULL;
+        sys->sys.pool = NULL;
 
     UpdateRects(vd, NULL, NULL, true);
 
@@ -304,9 +304,9 @@ static void Clean(vout_display_t *vd)
 {
     vout_display_sys_t *sys = vd->sys;
 
-    if (sys->pool)
-        picture_pool_Release(sys->pool);
-    sys->pool = NULL;
+    if (sys->sys.pool)
+        picture_pool_Release(sys->sys.pool);
+    sys->sys.pool = NULL;
 
     if (sys->off_dc)
         DeleteDC(sys->off_dc);
-- 
2.10.1.windows.1

