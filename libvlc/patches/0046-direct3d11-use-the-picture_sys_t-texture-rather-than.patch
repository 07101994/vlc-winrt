From bac54aafaf4f132151ad309ea4da50bde8f276fa Mon Sep 17 00:00:00 2001
From: Steve Lhomme <robux4@videolabs.io>
Date: Tue, 24 Jan 2017 13:21:32 +0100
Subject: [PATCH 46/62] direct3d11: use the picture_sys_t texture rather than a
 local quad one

picSys already has all the fields we need.
---
 modules/video_output/win32/direct3d11.c | 92 ++++++++++++++++++---------------
 1 file changed, 49 insertions(+), 43 deletions(-)

diff --git a/modules/video_output/win32/direct3d11.c b/modules/video_output/win32/direct3d11.c
index d45ccee..590d6f4 100644
--- a/modules/video_output/win32/direct3d11.c
+++ b/modules/video_output/win32/direct3d11.c
@@ -112,7 +112,6 @@ typedef struct
     UINT                      indexCount;
     ID3D11Buffer              *pVertexShaderConstants;
     picture_sys_t             picSys;
-    ID3D11Texture2D           *pTexture[D3D11_MAX_SHADER_VIEW];
     ID3D11Buffer              *pPixelShaderConstants[2];
     UINT                       PSConstantsCount;
     ID3D11PixelShader         *d3dpixelShader;
@@ -626,8 +625,8 @@ static const d3d_format_t *GetOutputFormat(vout_display_t *vd, vlc_fourcc_t i_sr
 }
 
 /* map texture planes to resource views */
-static int AllocateShaderView(vout_display_t *vd, const d3d_format_t *format, ID3D11Texture2D *texture[D3D11_MAX_SHADER_VIEW],
-                              int slice_index, ID3D11ShaderResourceView *resourceView[2])
+static int AllocateShaderView(vout_display_t *vd, const d3d_format_t *format,
+                              int slice_index, picture_sys_t *picsys)
 {
     HRESULT hr;
     vout_display_sys_t *sys = vd->sys;
@@ -649,12 +648,13 @@ static int AllocateShaderView(vout_display_t *vd, const d3d_format_t *format, ID
 
     for (i=0; i<D3D11_MAX_SHADER_VIEW; i++)
     {
-        if (!texture[i])
-            resourceView[i] = NULL;
+        if (!picsys->resource[i])
+            picsys->resourceView[i] = NULL;
         else
         {
             resviewDesc.Format = format->resourceFormat[i];
-            hr = ID3D11Device_CreateShaderResourceView(sys->d3ddevice, (ID3D11Resource *)texture[i], &resviewDesc, &resourceView[i]);
+            hr = ID3D11Device_CreateShaderResourceView(sys->d3ddevice, picsys->resource[i],
+                                                       &resviewDesc, &picsys->resourceView[i]);
             if (FAILED(hr)) {
                 msg_Err(vd, "Could not Create the Texture ResourceView %d slice %d. (hr=0x%lX)", i, slice_index, hr);
                 break;
@@ -666,8 +666,8 @@ static int AllocateShaderView(vout_display_t *vd, const d3d_format_t *format, ID
     {
         while (i >= 0)
         {
-            ID3D11ShaderResourceView_Release(resourceView[i]);
-            resourceView[i] = NULL;
+            ID3D11ShaderResourceView_Release(picsys->resourceView[i]);
+            picsys->resourceView[i] = NULL;
             i--;
         }
         return VLC_EGENERIC;
@@ -743,7 +743,7 @@ static picture_pool_t *Pool(vout_display_t *vd, unsigned pool_size)
             }
         }
 
-        if (AllocateShaderView(vd, vd->sys->picQuadConfig, picsys->texture, picture_count, picsys->resourceView) != VLC_SUCCESS)
+        if (AllocateShaderView(vd, vd->sys->picQuadConfig, picture_count, picsys) != VLC_SUCCESS)
             goto error;
 
         picture_resource_t resource = {
@@ -759,8 +759,6 @@ static picture_pool_t *Pool(vout_display_t *vd, unsigned pool_size)
         }
 
         pictures[picture_count] = picture;
-        /* each picture_t holds a ref to the context and release it on Destroy */
-        ID3D11DeviceContext_AddRef(picsys->context);
     }
     ID3D11Texture2D_Release(texture);
 
@@ -792,24 +790,39 @@ error:
     return vd->sys->sys.pool;
 }
 
-#ifdef HAVE_ID3D11VIDEODECODER
-static void DestroyDisplayPoolPicture(picture_t *picture)
+static void ReleasePictureResources(picture_sys_t *p_sys)
 {
-    picture_sys_t *p_sys = (picture_sys_t*) picture->p_sys;
-
     for (int i=0; i<D3D11_MAX_SHADER_VIEW; i++) {
-        if (p_sys->resourceView[i])
+        if (p_sys->resourceView[i]) {
             ID3D11ShaderResourceView_Release(p_sys->resourceView[i]);
-        if (p_sys->texture[i])
+            p_sys->resourceView[i] = NULL;
+        }
+        if (p_sys->texture[i]) {
             ID3D11Texture2D_Release(p_sys->texture[i]);
+            p_sys->texture[i] = NULL;
+        }
     }
-    if (p_sys->context)
+    if (p_sys->context) {
         ID3D11DeviceContext_Release(p_sys->context);
+        p_sys->context = NULL;
+    }
+}
+
+static void DestroyQuadPicture(picture_t *picture)
+{
+    picture_sys_t *p_sys = picture->p_sys;
+    ReleasePictureResources( p_sys );
+    /* belongs to the quad free(p_sys);*/
+    free(picture);
+}
 
+static void DestroyDisplayPoolPicture(picture_t *picture)
+{
+    picture_sys_t *p_sys = picture->p_sys;
+    ReleasePictureResources( p_sys );
     free(p_sys);
     free(picture);
 }
-#endif
 
 static HRESULT UpdateBackBuffer(vout_display_t *vd)
 {
@@ -1102,7 +1115,7 @@ static void Prepare(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
             WaitForSingleObjectEx( sys->context_lock, INFINITE, FALSE );
         }
         ID3D11DeviceContext_CopySubresourceRegion(sys->d3dcontext,
-                                                  (ID3D11Resource*) sys->picQuad.pTexture[KNOWN_DXGI_INDEX],
+                                                  sys->picQuad.picSys.resource[KNOWN_DXGI_INDEX],
                                                   0, 0, 0, 0,
                                                   p_sys->resource[KNOWN_DXGI_INDEX],
                                                   p_sys->slice_index, NULL);
@@ -1758,6 +1771,7 @@ static int Direct3D11CreatePool(vout_display_t *vd, video_format_t *fmt)
      * into, it's the picQuad used to display */
     picture_resource_t resource = {
         .p_sys = &sys->picQuad.picSys,
+        .pf_destroy = DestroyQuadPicture,
     };
 
     picture_t *picture = picture_NewFromResource(fmt, &resource);
@@ -2121,36 +2135,39 @@ static int AllocQuad(vout_display_t *vd, const video_format_t *fmt, d3d_quad_t *
         texDesc.Height &= ~1;
     }
 
-    hr = ID3D11Device_CreateTexture2D(sys->d3ddevice, &texDesc, NULL, &quad->pTexture[KNOWN_DXGI_INDEX]);
+    hr = ID3D11Device_CreateTexture2D(sys->d3ddevice, &texDesc, NULL, &quad->picSys.texture[KNOWN_DXGI_INDEX]);
     if (FAILED(hr)) {
         msg_Err(vd, "Could not Create the D3d11 Texture. (hr=0x%lX)", hr);
         goto error;
     }
     for (int i=KNOWN_DXGI_INDEX+1; i<D3D11_MAX_SHADER_VIEW; i++) {
         if (!cfg->resourceFormat[i])
-            quad->pTexture[i] = NULL;
+            quad->picSys.texture[i] = NULL;
         else
         {
-            quad->pTexture[i] = quad->pTexture[KNOWN_DXGI_INDEX];
-            ID3D11Texture2D_AddRef(quad->pTexture[i]);
+            quad->picSys.texture[i] = quad->picSys.texture[KNOWN_DXGI_INDEX];
+            ID3D11Texture2D_AddRef(quad->picSys.texture[i]);
         }
     }
 
-    hr = ID3D11DeviceContext_Map(sys->d3dcontext, (ID3D11Resource *)quad->pTexture[KNOWN_DXGI_INDEX], 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
+    hr = ID3D11DeviceContext_Map(sys->d3dcontext, quad->picSys.resource[KNOWN_DXGI_INDEX], 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
     if( FAILED(hr) ) {
         msg_Err(vd, "The texture cannot be mapped. (hr=0x%lX)", hr);
         goto error;
     }
-    ID3D11DeviceContext_Unmap(sys->d3dcontext, (ID3D11Resource *)quad->pTexture[KNOWN_DXGI_INDEX], 0);
+    ID3D11DeviceContext_Unmap(sys->d3dcontext, quad->picSys.resource[KNOWN_DXGI_INDEX], 0);
     if (mappedResource.RowPitch < p_chroma_desc->pixel_size * texDesc.Width) {
         msg_Err( vd, "The texture row pitch is too small (%d instead of %d)", mappedResource.RowPitch,
                  p_chroma_desc->pixel_size * texDesc.Width );
         goto error;
     }
 
-    if (AllocateShaderView(vd, cfg, quad->pTexture, 0, quad->picSys.resourceView) != VLC_SUCCESS)
+    if (AllocateShaderView(vd, cfg, 0, &quad->picSys) != VLC_SUCCESS)
         goto error;
 
+    quad->picSys.context = sys->d3dcontext;
+    ID3D11DeviceContext_AddRef(quad->picSys.context);
+
     if ( d3dpixelShader != NULL )
     {
         if (!AllocQuadVertices(vd, quad, fmt, projection))
@@ -2200,23 +2217,12 @@ static void ReleaseQuad(d3d_quad_t *quad)
         ID3D11Buffer_Release(quad->pVertexShaderConstants);
         quad->pVertexShaderConstants = NULL;
     }
-    for (int i=0; i<D3D11_MAX_SHADER_VIEW; i++) {
-        if (quad->pTexture[i])
-        {
-            ID3D11Texture2D_Release(quad->pTexture[i]);
-            quad->pTexture[i] = NULL;
-        }
-        if (quad->picSys.resourceView[i])
-        {
-            ID3D11ShaderResourceView_Release(quad->picSys.resourceView[i]);
-            quad->picSys.resourceView[i] = NULL;
-        }
-    }
     if (quad->d3dpixelShader)
     {
         ID3D11VertexShader_Release(quad->d3dpixelShader);
         quad->d3dpixelShader = NULL;
     }
+    ReleasePictureResources(&quad->picSys);
 }
 
 static void Direct3D11DestroyResources(vout_display_t *vd)
@@ -2325,8 +2331,8 @@ static int Direct3D11MapSubpicture(vout_display_t *vd, int *subpicture_region_co
 
         for (int j = 0; j < sys->d3dregion_count; j++) {
             picture_t *cache = sys->d3dregions[j];
-            if (cache != NULL && ((d3d_quad_t *) cache->p_sys)->pTexture) {
-                ID3D11Texture2D_GetDesc( ((d3d_quad_t *) cache->p_sys)->pTexture[KNOWN_DXGI_INDEX], &texDesc );
+            if (cache != NULL && ((d3d_quad_t *) cache->p_sys)->picSys.texture[KNOWN_DXGI_INDEX]) {
+                ID3D11Texture2D_GetDesc( ((d3d_quad_t *) cache->p_sys)->picSys.texture[KNOWN_DXGI_INDEX], &texDesc );
                 if (texDesc.Format == sys->d3dregion_format->formatTexture &&
                     texDesc.Width  == r->fmt.i_visible_width &&
                     texDesc.Height == r->fmt.i_visible_height) {
@@ -2365,7 +2371,7 @@ static int Direct3D11MapSubpicture(vout_display_t *vd, int *subpicture_region_co
             quad_picture = (*region)[i];
         }
 
-        hr = ID3D11DeviceContext_Map(sys->d3dcontext, (ID3D11Resource *)((d3d_quad_t *) quad_picture->p_sys)->pTexture[KNOWN_DXGI_INDEX], 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
+        hr = ID3D11DeviceContext_Map(sys->d3dcontext, ((d3d_quad_t *) quad_picture->p_sys)->picSys.resource[KNOWN_DXGI_INDEX], 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
         if( SUCCEEDED(hr) ) {
             err = CommonUpdatePicture(quad_picture, NULL, mappedResource.pData, mappedResource.RowPitch);
             if (err != VLC_SUCCESS) {
@@ -2376,7 +2382,7 @@ static int Direct3D11MapSubpicture(vout_display_t *vd, int *subpicture_region_co
 
             picture_CopyPixels(quad_picture, r->p_picture);
 
-            ID3D11DeviceContext_Unmap(sys->d3dcontext, (ID3D11Resource *)((d3d_quad_t *) quad_picture->p_sys)->pTexture[KNOWN_DXGI_INDEX], 0);
+            ID3D11DeviceContext_Unmap(sys->d3dcontext, ((d3d_quad_t *) quad_picture->p_sys)->picSys.resource[KNOWN_DXGI_INDEX], 0);
         } else {
             msg_Err(vd, "Failed to map the SPU texture (hr=0x%lX)", hr );
             picture_Release(quad_picture);
-- 
2.10.1.windows.1

