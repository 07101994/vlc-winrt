From a5de4b3d412b9598fc537833d984971ac9d7a44b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Hugo=20Beauz=C3=A9e-Luyssen?= <hugo@beauzee.fr>
Date: Tue, 14 Jun 2016 17:07:01 +0200
Subject: [PATCH 01/11] contribs: dsm: Discover using all interfaces

---
 contrib/src/libdsm/all-interfaces.patch | 174 ++++++++++++++++++++++++++++++++
 contrib/src/libdsm/rules.mak            |   1 +
 2 files changed, 175 insertions(+)
 create mode 100644 contrib/src/libdsm/all-interfaces.patch

diff --git a/contrib/src/libdsm/all-interfaces.patch b/contrib/src/libdsm/all-interfaces.patch
new file mode 100644
index 0000000..f68ad13
--- /dev/null
+++ b/contrib/src/libdsm/all-interfaces.patch
@@ -0,0 +1,174 @@
+From 1cfffad72aa7ac0307e4fa0e5babe81658c9caa7 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Hugo=20Beauz=C3=A9e-Luyssen?= <hugo@beauzee.fr>
+Date: Mon, 13 Jun 2016 17:35:14 +0200
+Subject: [PATCH] Discover on all available interfaces
+
+---
+ src/netbios_ns.c | 112 +++++++++++++++++++++++++++++++++++++++++--------------
+ 1 file changed, 85 insertions(+), 27 deletions(-)
+
+diff --git a/src/netbios_ns.c b/src/netbios_ns.c
+index a6ec370..57f531c 100644
+--- a/src/netbios_ns.c
++++ b/src/netbios_ns.c
+@@ -57,6 +57,12 @@
+ # include <sys/socket.h>
+ #endif
+ 
++#ifndef _WIN32
++# include <sys/types.h>
++# include <ifaddrs.h>
++# include <net/if.h>
++#endif
++
+ #include <bdsm/netbios_ns.h>
+ 
+ #include "bdsm_debug.h"
+@@ -127,9 +133,6 @@ struct netbios_ns_name_query
+     }u;
+ };
+ 
+-static netbios_ns_entry *netbios_ns_inverse_internal(netbios_ns *ns,
+-                                                     uint32_t ip);
+-
+ static int    ns_open_socket(netbios_ns *ns)
+ {
+     int sock_opt;
+@@ -149,7 +152,7 @@ static int    ns_open_socket(netbios_ns *ns)
+ 
+     ns->addr.sin_family       = AF_INET;
+     ns->addr.sin_port         = htons(0);
+-    ns->addr.sin_addr.s_addr  = 0;
++    ns->addr.sin_addr.s_addr  = INADDR_ANY;
+     if (bind(ns->socket, (struct sockaddr *)&ns->addr, sizeof(ns->addr)) < 0)
+         goto error;
+ 
+@@ -243,15 +246,72 @@ static uint16_t query_type_nb = 0x2000;
+ static uint16_t query_type_nbstat = 0x2100;
+ static uint16_t query_class_in = 0x0100;
+ 
++static ssize_t netbios_ns_send_packet(netbios_ns* ns, netbios_query* q, uint32_t ip)
++{
++    struct sockaddr_in  addr;
++
++    addr.sin_addr.s_addr  = ip;
++    addr.sin_family       = AF_INET;
++    addr.sin_port         = htons(NETBIOS_PORT_NAME);
++
++    BDSM_dbg("Sending netbios packet to %s\n", inet_ntoa(addr.sin_addr));
++    return sendto(ns->socket, (void *)q->packet,
++                  sizeof(netbios_query_packet) + q->cursor, 0,
++                  (struct sockaddr *)&addr, sizeof(struct sockaddr_in));
++}
++
++#ifndef _WIN32
++
++static void netbios_ns_broadcast_packet(netbios_ns* ns, netbios_query* q)
++{
++    struct ifaddrs *addrs;
++    if (getifaddrs(&addrs) != 0)
++        return;
++    for (struct ifaddrs *a = addrs; a != NULL; a = a->ifa_next)
++    {
++        if ((a->ifa_flags & IFF_BROADCAST) == 0 || (a->ifa_flags & IFF_UP) == 0)
++            continue;
++        if (a->ifa_addr->sa_family != PF_INET)
++            continue;
++        struct sockaddr_in* sin = (struct sockaddr_in*)a->ifa_broadaddr;
++
++        uint32_t ip = sin->sin_addr.s_addr;
++        if (netbios_ns_send_packet(ns, q, ip) != 0)
++            BDSM_perror("Failed to broadcast");
++    }
++    freeifaddrs(addrs);
++}
++
++#else
++
++static void netbios_ns_broadcast_packet(netbios_ns* ns, netbios_query* q)
++{
++    INTERFACE_INFO infolist[16];
++    DWORD dwBytesReturned = 0;
++    if (WSAIoctl(ns->socket, SIO_GET_INTERFACE_LIST, NULL, 0, (void*)infolist, sizeof(infolist), &dwBytesReturned, NULL, NULL) != 0)
++        return;
++    unsigned int dwNumInterfaces = dwBytesReturned / sizeof(INTERFACE_INFO);
++
++    for (unsigned int index = 0; index < dwNumInterfaces; index++)
++    {
++        if (infolist[index].iiAddress.Address.sa_family == AF_INET)
++        {
++            uint32_t broadcast = infolist[index].iiAddress.AddressIn.sin_addr.s_addr & infolist[index].iiNetmask.AddressIn.sin_addr.s_addr;
++            broadcast |= ~ infolist[index].iiNetmask.AddressIn.sin_addr.S_un.S_addr;
++            if (netbios_ns_send_packet(ns, q, broadcast) != 0)
++                BDSM_perror("Failed to broadcast");
++        }
++    }
++}
++
++#endif
++
+ static int netbios_ns_send_name_query(netbios_ns *ns,
+                                       uint32_t ip,
+                                       enum name_query_type type,
+                                       const char *name,
+                                       uint16_t query_flag)
+ {
+-    struct sockaddr_in  addr;
+-    ssize_t             sent;
+-    uint16_t            trn_id;
+     uint16_t            query_type;
+     netbios_query       *q;
+ 
+@@ -283,31 +343,29 @@ static int netbios_ns_send_name_query(netbios_ns *ns,
+     netbios_query_append(q, (const char *)&query_class_in, 2);
+     q->packet->queries = htons(1);
+ 
+-    if (ip == 0)
+-        ip = 0xFFFFFFFF; /* inet_aton("255.255.255.255", (struct in_addr *)&ip); */
+-
+-    trn_id = ns->last_trn_id + 1; // Increment transaction ID, not to reuse them
+-    q->packet->trn_id = htons(trn_id);
+-
+-    addr.sin_addr.s_addr  = ip;
+-    addr.sin_family       = AF_INET;
+-    addr.sin_port         = htons(NETBIOS_PORT_NAME);
+-
+-    sent = sendto(ns->socket, (void *)q->packet,
+-                  sizeof(netbios_query_packet) + q->cursor, 0,
+-                  (struct sockaddr *)&addr, sizeof(struct sockaddr_in));
++    // Increment transaction ID, not to reuse them
++    q->packet->trn_id = htons(ns->last_trn_id + 1);
+ 
+-    netbios_query_destroy(q);
+-
+-    if (sent < 0)
++    if (ip != 0)
+     {
+-        BDSM_perror("netbios_ns_send_name_query: ");
+-        return -1;
++        ssize_t sent = netbios_ns_send_packet(ns, q, ip);
++        if (sent < 0)
++        {
++            BDSM_perror("netbios_ns_send_name_query: ");
++            netbios_query_destroy(q);
++            return -1;
++        }
++        else
++            BDSM_dbg("netbios_ns_send_name_query, name query sent for '*'.\n");
+     }
+     else
+-        BDSM_dbg("netbios_ns_send_name_query, name query sent for '*'.\n");
++    {
++        netbios_ns_broadcast_packet(ns, q);
++    }
++
++    netbios_query_destroy(q);
+ 
+-    ns->last_trn_id = trn_id; // Remember the last transaction id.
++    ns->last_trn_id++; // Remember the last transaction id.
+     return 0;
+ }
+ 
+-- 
+2.8.1
+
diff --git a/contrib/src/libdsm/rules.mak b/contrib/src/libdsm/rules.mak
index e1227b3..55f8af8 100644
--- a/contrib/src/libdsm/rules.mak
+++ b/contrib/src/libdsm/rules.mak
@@ -20,6 +20,7 @@ endif
 
 libdsm: libdsm-$(LIBDSM_VERSION).tar.gz .sum-libdsm
 	$(UNPACK)
+	$(APPLY) $(SRC)/libdsm/all-interfaces.patch
 	$(MOVE)
 
 DEPS_libdsm = libtasn1 iconv
-- 
2.8.1

