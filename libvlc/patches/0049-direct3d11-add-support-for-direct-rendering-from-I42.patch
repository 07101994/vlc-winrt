From 067f95124d979c515a7712ab8f5f7aac1b4ab3db Mon Sep 17 00:00:00 2001
From: Steve Lhomme <robux4@videolabs.io>
Date: Wed, 25 Jan 2017 18:15:52 +0100
Subject: [PATCH 49/50] direct3d11: add support for direct rendering from I420
 decoders

Each plane of the I420 is using a separate textures. These 3 planes are
reassembled in the pixel shader that is using a DXGI_FORMAT_UNKNWON format
to allow more flexible shader resource handling.

The texture(s) must be not mapped to the CPU to be drawn on the SwapChain, so
we use an intermediate pool of staging textures for the decoder, this staging
textures are copied in the quad just before being displayed.

Each staging texture is mapped once to the CPU to keep consistency between
frames references. Once this mapping is done we don't map/unmap that texture
anymore during its lifetime.
---
 modules/video_chroma/d3d11_fmt.h        |   3 +
 modules/video_output/win32/direct3d11.c | 290 +++++++++++++++++++++++++++-----
 2 files changed, 248 insertions(+), 45 deletions(-)

diff --git a/modules/video_chroma/d3d11_fmt.h b/modules/video_chroma/d3d11_fmt.h
index caea919a77..3e2aee378b 100644
--- a/modules/video_chroma/d3d11_fmt.h
+++ b/modules/video_chroma/d3d11_fmt.h
@@ -40,6 +40,9 @@ struct picture_sys_t
     ID3D11VideoProcessorInputView *inputView; /* when used as processor input */
     ID3D11ShaderResourceView      *resourceView[D3D11_MAX_SHADER_VIEW];
     DXGI_FORMAT                   formatTexture;
+    bool                          mapped;
+	/* once a dynamic texture is mapped to the CPU we don't want to discard the buffer */
+    bool                          locked;
 };
 
 /* index to use for texture/resource that use a known DXGI format
diff --git a/modules/video_output/win32/direct3d11.c b/modules/video_output/win32/direct3d11.c
index 8e1779fade..974f0a6a4a 100644
--- a/modules/video_output/win32/direct3d11.c
+++ b/modules/video_output/win32/direct3d11.c
@@ -389,23 +389,123 @@ static const char *globPixelShaderBiplanarYUYV_2RGB = "\
   }\
 ";
 
-static int Direct3D11MapPoolTexture(picture_t *picture)
+
+/* for triplanar 4:2:0 source */
+static const char *globPixelShaderTriplanarI420_2RGB = "\
+  cbuffer PS_CONSTANT_BUFFER : register(b0)\
+  {\
+    float Opacity;\
+    float opacityPadding[3];\
+  };\
+  cbuffer PS_COLOR_TRANSFORM : register(b1)\
+  {\
+    float WhitePointX;\
+    float WhitePointY;\
+    float WhitePointZ;\
+    float whitePadding;\
+    float4x4 Colorspace;\
+  };\
+  Texture2D%s shaderTexture[" STRINGIZE(D3D11_MAX_SHADER_VIEW) "];\
+  SamplerState SampleType;\
+  \
+  struct PS_INPUT\
+  {\
+    float4 Position   : SV_POSITION;\
+    float4 Texture    : TEXCOORD0;\
+  };\
+  \
+  float4 PS( PS_INPUT In ) : SV_TARGET\
+  {\
+    float4 yuv;\
+    float4 rgba;\
+    yuv.x = shaderTexture[0].Sample(SampleType, In.Texture).x;\
+    yuv.y = shaderTexture[1].Sample(SampleType, In.Texture).x;\
+    yuv.z = shaderTexture[2].Sample(SampleType, In.Texture).x;\
+    yuv.a  = Opacity;\
+    yuv.x  += WhitePointX;\
+    yuv.y  += WhitePointY;\
+    yuv.z  += WhitePointZ;\
+    rgba = saturate(mul(yuv, Colorspace));\
+    return rgba;\
+  }\
+";
+
+static int Direct3D11MapPoolTexture(picture_t *picture, D3D11_MAP map_mode)
 {
     picture_sys_t *p_sys = picture->p_sys;
     D3D11_MAPPED_SUBRESOURCE mappedResource;
     HRESULT hr;
-    hr = ID3D11DeviceContext_Map(p_sys->context, p_sys->resource[KNOWN_DXGI_INDEX], 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
-    if( FAILED(hr) )
+
+    if ( p_sys->formatTexture == DXGI_FORMAT_UNKNOWN )
     {
-        return VLC_EGENERIC;
+        D3D11_TEXTURE2D_DESC texDesc;
+        int i;
+        uint8_t *planes[D3D11_MAX_SHADER_VIEW];
+        unsigned pitches[D3D11_MAX_SHADER_VIEW];
+        unsigned heights[D3D11_MAX_SHADER_VIEW];
+
+        for (i = 0; i < picture->i_planes; i++) {
+            hr = ID3D11DeviceContext_Map(p_sys->context, p_sys->resource[i],
+                    0, map_mode, 0, &mappedResource);
+            if( FAILED(hr) )
+            {
+                while (i-- >= 0)
+                    ID3D11DeviceContext_Unmap(p_sys->context, p_sys->resource[i+1], 0);
+                return VLC_EGENERIC;
+            }
+            ID3D11Texture2D_GetDesc(p_sys->texture[i], &texDesc);
+            planes[i]  = mappedResource.pData;
+            pitches[i] = mappedResource.RowPitch;
+            heights[i] = texDesc.Height;
+        }
+        for (; i < D3D11_MAX_SHADER_VIEW; i++) {
+            planes[i]  = NULL;
+            pitches[i] = 0;
+            heights[i] = 0;
+        }
+        p_sys->mapped = true;
+
+        return CommonUpdatePictureSplit(picture, planes, pitches, heights);
     }
+
+    hr = ID3D11DeviceContext_Map(p_sys->context, p_sys->resource[KNOWN_DXGI_INDEX],
+                                 0, map_mode, 0, &mappedResource);
+    if( FAILED(hr) )
+        return VLC_EGENERIC;
+    p_sys->mapped = true;
+
     return CommonUpdatePicture(picture, NULL, mappedResource.pData, mappedResource.RowPitch);
 }
 
+/* map a texture to CPU that will also be used for drawing to the swapchain */
+static int Direct3D11LockTexture(picture_t *picture)
+{
+    return Direct3D11MapPoolTexture(picture, D3D11_MAP_WRITE_DISCARD);
+}
+
+static int Direct3D11LockDirectTexture(picture_t *picture)
+{
+    picture_sys_t *p_sys = picture->p_sys;
+    int res = Direct3D11MapPoolTexture(picture, D3D11_MAP_WRITE);
+    if (res == VLC_SUCCESS) {
+        p_sys->locked = true;
+    }
+    return res;
+}
+
 static void Direct3D11UnmapPoolTexture(picture_t *picture)
 {
     picture_sys_t *p_sys = picture->p_sys;
-    ID3D11DeviceContext_Unmap(p_sys->context, p_sys->resource[KNOWN_DXGI_INDEX], 0);
+    if (p_sys->mapped) {
+        if ( p_sys->formatTexture == DXGI_FORMAT_UNKNOWN ) {
+            for (int i = 0; i < picture->i_planes; i++) {
+                ID3D11DeviceContext_Unmap(p_sys->context, p_sys->resource[i], 0);
+            }
+        } else {
+            ID3D11DeviceContext_Unmap(p_sys->context, p_sys->resource[KNOWN_DXGI_INDEX], 0);
+        }
+        p_sys->mapped = false;
+    }
 }
 
 #if !VLC_WINSTORE_APP
@@ -488,6 +588,12 @@ static bool is_d3d11_opaque(vlc_fourcc_t chroma)
     }
 }
 
+static bool is_direct_rendering(vout_display_t *vd)
+{
+    return is_d3d11_opaque(vd->fmt.i_chroma) ||
+           vd->sys->picQuadConfig->formatTexture == DXGI_FORMAT_UNKNOWN;
+}
+
 #if VLC_WINSTORE_APP
 static bool GetRect(const vout_display_sys_win32_t *p_sys, RECT *out)
 {
@@ -541,10 +647,10 @@ static int Open(vlc_object_t *object)
     video_format_Clean(&vd->fmt);
     video_format_Copy(&vd->fmt, &fmt);
 
-    vd->info.is_slow              = !is_d3d11_opaque(fmt.i_chroma);
+    vd->info.is_slow              = !is_direct_rendering(vd);
     vd->info.has_double_click     = true;
     vd->info.has_hide_mouse       = false;
-    vd->info.has_pictures_invalid = !is_d3d11_opaque(fmt.i_chroma);
+    vd->info.has_pictures_invalid = !is_direct_rendering(vd);
 
     if (var_InheritBool(vd, "direct3d11-hw-blending") &&
         vd->sys->d3dregion_format != NULL)
@@ -601,8 +707,14 @@ static const d3d_format_t *GetOutputFormat(vout_display_t *vd, vlc_fourcc_t i_sr
         if (!b_allow_opaque && is_d3d11_opaque(output_format->fourcc))
             continue;
 
+        DXGI_FORMAT textureFormat;
+        if (output_format->formatTexture == DXGI_FORMAT_UNKNOWN)
+            textureFormat = output_format->resourceFormat[0];
+        else
+            textureFormat = output_format->formatTexture;
+
         if( SUCCEEDED( ID3D11Device_CheckFormatSupport(sys->d3ddevice,
-                                                       output_format->formatTexture,
+                                                       textureFormat,
                                                        &i_formatSupport)) &&
                 ( i_formatSupport & i_quadSupportFlags ) == i_quadSupportFlags )
         {
@@ -666,9 +778,11 @@ static int AllocateShaderView(vout_display_t *vd, const d3d_format_t *format,
 
 static int AllocateTextures(vout_display_t *vd, const d3d_format_t *cfg,
                             const video_format_t *fmt, unsigned pool_size,
-                            ID3D11Texture2D *textures[])
+                            ID3D11Texture2D *textures[],
+                            bool staging)
 {
-    int plane;
+    plane_t           planes[PICTURE_PLANE_MAX];
+    int               plane, plane_count;
     HRESULT hr;
     ID3D11Texture2D *slicedTexture = NULL;
     D3D11_TEXTURE2D_DESC texDesc;
@@ -676,33 +790,68 @@ static int AllocateTextures(vout_display_t *vd, const d3d_format_t *cfg,
     texDesc.MipLevels = 1;
     texDesc.SampleDesc.Count = 1;
     texDesc.MiscFlags = 0; //D3D11_RESOURCE_MISC_SHARED;
-    texDesc.Usage = D3D11_USAGE_DEFAULT;
-    texDesc.CPUAccessFlags = 0;
-    texDesc.Format = cfg->formatTexture;
-    texDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
-    if (is_d3d11_opaque(fmt->i_chroma)) {
-        texDesc.BindFlags |= D3D11_BIND_DECODER;
-        texDesc.Usage = D3D11_USAGE_DEFAULT;
-        texDesc.CPUAccessFlags = 0;
+
+    if (cfg->formatTexture == DXGI_FORMAT_UNKNOWN) {
+        if (picture_SetupPlanes(fmt->i_chroma, fmt, planes, &plane_count) != VLC_SUCCESS ||
+            plane_count == 0)
+        {
+            msg_Dbg(vd, "failed to get the pixel format planes for %4.4s", (char *)&fmt->i_chroma);
+            return VLC_EGENERIC;
+        }
+        assert(plane_count <= D3D11_MAX_SHADER_VIEW);
+
+        texDesc.Format = cfg->resourceFormat[0];
+        assert(cfg->resourceFormat[1] == cfg->resourceFormat[0]);
+        assert(cfg->resourceFormat[2] == cfg->resourceFormat[0]);
+        if (staging) {
+            texDesc.Usage = D3D11_USAGE_STAGING;
+            texDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
+        } else {
+            texDesc.Usage = D3D11_USAGE_DEFAULT;
+            texDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
+            texDesc.CPUAccessFlags = 0;
+        }
+        texDesc.ArraySize = 1;
     } else {
-        texDesc.Usage = D3D11_USAGE_DYNAMIC;
-        texDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
-    }
-    texDesc.ArraySize = pool_size;
-    texDesc.Height = fmt->i_height;
-    texDesc.Width = fmt->i_width;
+        plane_count = 1;
+        texDesc.Format = cfg->formatTexture;
+        texDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
+        if (is_d3d11_opaque(fmt->i_chroma)) {
+            texDesc.BindFlags |= D3D11_BIND_DECODER;
+            texDesc.Usage = D3D11_USAGE_DEFAULT;
+            texDesc.CPUAccessFlags = 0;
+        } else {
+            texDesc.Usage = D3D11_USAGE_DYNAMIC;
+            texDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
+        }
+        texDesc.ArraySize = pool_size;
 
-    hr = ID3D11Device_CreateTexture2D( vd->sys->d3ddevice, &texDesc, NULL, &slicedTexture );
-    if (FAILED(hr)) {
-        msg_Err(vd, "CreateTexture2D failed for the %d pool. (hr=0x%0lx)", pool_size, hr);
-        goto error;
+        texDesc.Height = fmt->i_height;
+        texDesc.Width = fmt->i_width;
+        hr = ID3D11Device_CreateTexture2D( vd->sys->d3ddevice, &texDesc, NULL, &slicedTexture );
+        if (FAILED(hr)) {
+            msg_Err(vd, "CreateTexture2D failed for the %d pool. (hr=0x%0lx)", pool_size, hr);
+            goto error;
+        }
     }
 
     for (unsigned picture_count = 0; picture_count < pool_size; picture_count++) {
-        textures[picture_count * D3D11_MAX_SHADER_VIEW] = slicedTexture;
-        ID3D11Texture2D_AddRef(slicedTexture);
-
-        for (plane = 1; plane < D3D11_MAX_SHADER_VIEW; plane++) {
+        for (plane = 0; plane < plane_count; plane++)
+        {
+            if (slicedTexture) {
+                textures[picture_count * D3D11_MAX_SHADER_VIEW + plane] = slicedTexture;
+                ID3D11Texture2D_AddRef(slicedTexture);
+            } else {
+                texDesc.Height = planes[plane].i_lines;
+                texDesc.Width = planes[plane].i_pitch;
+                hr = ID3D11Device_CreateTexture2D( vd->sys->d3ddevice, &texDesc, NULL, &textures[picture_count * D3D11_MAX_SHADER_VIEW + plane] );
+                if (FAILED(hr)) {
+                    msg_Err(vd, "CreateTexture2D failed for the %d pool. (hr=0x%0lx)", pool_size, hr);
+                    goto error;
+                }
+            }
+        }
+        for (; plane < D3D11_MAX_SHADER_VIEW; plane++) {
             if (!cfg->resourceFormat[plane])
                 textures[picture_count * D3D11_MAX_SHADER_VIEW + plane] = NULL;
             else
@@ -748,7 +897,7 @@ static picture_pool_t *Pool(vout_display_t *vd, unsigned pool_size)
     if (!pictures)
         goto error;
 
-    if (AllocateTextures(vd, vd->sys->picQuadConfig, &vd->fmt, pool_size, textures))
+    if (AllocateTextures(vd, vd->sys->picQuadConfig, &vd->fmt, pool_size, textures, true))
         goto error;
 
     for (picture_count = 0; picture_count < pool_size; picture_count++) {
@@ -759,7 +908,8 @@ static picture_pool_t *Pool(vout_display_t *vd, unsigned pool_size)
         for (plane = 0; plane < D3D11_MAX_SHADER_VIEW; plane++)
             picsys->texture[plane] = textures[picture_count * D3D11_MAX_SHADER_VIEW + plane];
 
-        if (AllocateShaderView(vd, vd->sys->picQuadConfig, picture_count, picsys) != VLC_SUCCESS)
+        if ( vd->sys->picQuadConfig->formatTexture != DXGI_FORMAT_UNKNOWN &&
+             AllocateShaderView(vd, vd->sys->picQuadConfig, picture_count, picsys) )
             goto error;
 
         picsys->slice_index = picture_count;
@@ -787,6 +937,10 @@ static picture_pool_t *Pool(vout_display_t *vd, unsigned pool_size)
 
     picture_pool_configuration_t pool_cfg;
     memset(&pool_cfg, 0, sizeof(pool_cfg));
+    if (vd->sys->picQuadConfig->formatTexture == DXGI_FORMAT_UNKNOWN) {
+        pool_cfg.lock = Direct3D11LockDirectTexture;
+        pool_cfg.unlock = Direct3D11UnmapPoolTexture;
+    }
     pool_cfg.picture_count = pool_size;
     pool_cfg.picture       = pictures;
 
@@ -1144,6 +1298,31 @@ static void Prepare(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
     }
 #endif
 
+    if (picture->p_sys->formatTexture == DXGI_FORMAT_UNKNOWN)
+    {
+        picture_sys_t *p_sys = picture->p_sys;
+        D3D11_TEXTURE2D_DESC texDesc;
+
+        Direct3D11UnmapPoolTexture(picture);
+        for (int plane = 0; plane < D3D11_MAX_SHADER_VIEW; plane++)
+        {
+            if (!p_sys->resource[plane])
+                continue;
+
+            ID3D11Texture2D_GetDesc(sys->picQuad.picSys.texture[plane], &texDesc);
+            D3D11_BOX box = {
+                .bottom = texDesc.Height,
+                .right = texDesc.Width,
+                .back = 1,
+            };
+            ID3D11DeviceContext_CopySubresourceRegion(sys->d3dcontext,
+                                                      sys->picQuad.picSys.resource[plane],
+                                                      0, 0, 0, 0,
+                                                      p_sys->resource[plane],
+                                                      0, &box);
+        }
+    }
+
     if (subpicture) {
         int subpicture_region_count    = 0;
         picture_t **subpicture_regions = NULL;
@@ -1291,6 +1470,8 @@ static const char *GetFormatPixelShader(const d3d_format_t *format)
     case DXGI_FORMAT_B8G8R8A8_UNORM:
     case DXGI_FORMAT_B5G6R5_UNORM:
         return globPixelShaderDefault;
+    case DXGI_FORMAT_UNKNOWN:
+        return globPixelShaderTriplanarI420_2RGB;
     default:
         return NULL;
     }
@@ -1782,8 +1963,9 @@ static int Direct3D11CreatePool(vout_display_t *vd, video_format_t *fmt)
 {
     vout_display_sys_t *sys = vd->sys;
 
-    if ( is_d3d11_opaque(fmt->i_chroma) )
-        /* a D3D11VA pool will be created when needed */
+    if ( is_d3d11_opaque(fmt->i_chroma) ||
+         vd->sys->picQuadConfig->formatTexture == DXGI_FORMAT_UNKNOWN )
+        /* a decoder pool will be created when needed */
         return VLC_SUCCESS;
 
     picture_resource_t resource = {
@@ -1800,7 +1982,7 @@ static int Direct3D11CreatePool(vout_display_t *vd, video_format_t *fmt)
     memset(&pool_cfg, 0, sizeof(pool_cfg));
     pool_cfg.picture_count = 1;
     pool_cfg.picture       = &picture;
-    pool_cfg.lock          = Direct3D11MapPoolTexture;
+    pool_cfg.lock          = Direct3D11LockTexture;
     //pool_cfg.unlock        = Direct3D11UnmapPoolTexture;
 
     sys->sys.pool = picture_pool_NewExtended(&pool_cfg);
@@ -1821,12 +2003,29 @@ static void Direct3D11DestroyPool(vout_display_t *vd)
     sys->sys.pool = NULL;
 }
 
-static void SetupQuadFlat(d3d_vertex_t *dst_data, const video_format_t *fmt, WORD *triangle_pos)
+static void SetupQuadFlat(d3d_vertex_t *dst_data, const video_format_t *fmt, const d3d_format_t *cfg, WORD *triangle_pos)
 {
-    float right  =  (float) (2*fmt->i_width-fmt->i_visible_width-2*fmt->i_x_offset) / (float) fmt->i_visible_width;
+    plane_t           planes[PICTURE_PLANE_MAX];
+    int               plane_count;
+    unsigned int      width, height;
+
+    if ( cfg->formatTexture == DXGI_FORMAT_UNKNOWN &&
+         picture_SetupPlanes(fmt->i_chroma, fmt, planes, &plane_count) == VLC_SUCCESS )
+    {
+        /* get the visible area from the decoded luminance plane */
+        width  = planes[0].i_pitch;
+        height = planes[0].i_lines;
+    }
+    else
+    {
+        width = fmt->i_width;
+        height = fmt->i_height;
+    }
+
+    float right  =  (float) (2*width-fmt->i_visible_width-2*fmt->i_x_offset) / (float) fmt->i_visible_width;
     float left   = -(float) (2*fmt->i_x_offset + fmt->i_visible_width) / (float) fmt->i_visible_width;
     float top    =  (float) (2*fmt->i_y_offset + fmt->i_visible_height) / (float) fmt->i_visible_height;
-    float bottom = -(float) (2*fmt->i_height-fmt->i_visible_height-2*fmt->i_y_offset) / (float) fmt->i_visible_height;
+    float bottom = -(float) (2*height-fmt->i_visible_height-2*fmt->i_y_offset) / (float) fmt->i_visible_height;
 
     // bottom left
     dst_data[0].position.x = left;
@@ -1915,7 +2114,8 @@ static void SetupQuadSphere(d3d_vertex_t *dst_data, WORD *triangle_pos)
     }
 }
 
-static bool AllocQuadVertices(vout_display_t *vd, d3d_quad_t *quad, const video_format_t *fmt, video_projection_mode_t projection)
+static bool AllocQuadVertices(vout_display_t *vd, d3d_quad_t *quad, const video_format_t *fmt,
+                              const d3d_format_t *cfg, video_projection_mode_t projection)
 {
     HRESULT hr;
     D3D11_MAPPED_SUBRESOURCE mappedResource;
@@ -1982,7 +2182,7 @@ static bool AllocQuadVertices(vout_display_t *vd, d3d_quad_t *quad, const video_
     WORD *triangle_pos = mappedResource.pData;
 
     if ( projection == PROJECTION_MODE_RECTANGULAR )
-        SetupQuadFlat(dst_data, fmt, triangle_pos);
+        SetupQuadFlat(dst_data, fmt, cfg, triangle_pos);
     else
         SetupQuadSphere(dst_data, triangle_pos);
 
@@ -2122,13 +2322,13 @@ static int AllocQuad(vout_display_t *vd, const video_format_t *fmt, d3d_quad_t *
         SetQuadVSProjection( vd, quad, &vd->cfg->viewpoint );
     }
 
-    if (AllocateTextures(vd, cfg, fmt, 1, textures))
+    if (AllocateTextures(vd, cfg, fmt, 1, textures, false))
         goto error;
 
     for (int i=0; i<D3D11_MAX_SHADER_VIEW; i++)
         quad->picSys.texture[i] = textures[i];
 
-    if (!is_d3d11_opaque(fmt->i_chroma)) {
+    if (cfg->formatTexture != DXGI_FORMAT_UNKNOWN && !is_d3d11_opaque(fmt->i_chroma)) {
         D3D11_MAPPED_SUBRESOURCE mappedResource;
         int Width  = fmt->i_width;
         int Height = fmt->i_height;
@@ -2174,7 +2374,7 @@ static int AllocQuad(vout_display_t *vd, const video_format_t *fmt, d3d_quad_t *
 
     if ( d3dpixelShader != NULL )
     {
-        if (!AllocQuadVertices(vd, quad, fmt, projection))
+        if (!AllocQuadVertices(vd, quad, fmt, cfg, projection))
             goto error;
 
         if (projection == PROJECTION_MODE_RECTANGULAR)
-- 
2.11.0

