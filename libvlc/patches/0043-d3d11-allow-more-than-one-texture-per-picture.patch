From 6e8820b0405790e0f9e4039bc27604ab29dedca7 Mon Sep 17 00:00:00 2001
From: Steve Lhomme <robux4@videolabs.io>
Date: Tue, 24 Jan 2017 11:03:42 +0100
Subject: [PATCH 43/62] d3d11: allow more than one texture per picture

This way we can have a custom I420 with a texture for each plane
---
 modules/codec/avcodec/d3d11va.c         |  26 ++++----
 modules/video_chroma/d3d11_fmt.h        |   8 ++-
 modules/video_chroma/d3d11_surface.c    |   8 ++-
 modules/video_output/win32/direct3d11.c | 105 +++++++++++++++++++-------------
 4 files changed, 88 insertions(+), 59 deletions(-)

diff --git a/modules/codec/avcodec/d3d11va.c b/modules/codec/avcodec/d3d11va.c
index c33f77c..414ad08 100644
--- a/modules/codec/avcodec/d3d11va.c
+++ b/modules/codec/avcodec/d3d11va.c
@@ -252,7 +252,7 @@ static int Extract(vlc_va_t *va, picture_t *output, uint8_t *data)
     {
         picture_sys_t *p_sys_out = output->p_sys;
 
-        assert(p_sys_out->texture != NULL);
+        assert(p_sys_out->texture[KNOWN_DXGI_INDEX] != NULL);
 
 #ifdef ID3D11VideoContext_VideoProcessorBlt
         if (sys->videoProcessor)
@@ -272,7 +272,7 @@ static int Extract(vlc_va_t *va, picture_t *output, uint8_t *data)
                 };
 
                 HRESULT hr = ID3D11VideoDevice_CreateVideoProcessorOutputView((ID3D11VideoDevice*) sys->dx_sys.d3ddec,
-                                                                 p_sys_out->resource,
+                                                                 p_sys_out->resource[KNOWN_DXGI_INDEX],
                                                                  sys->procEnumerator,
                                                                  &outDesc,
                                                                  (ID3D11VideoProcessorOutputView**) &p_sys_out->decoder);
@@ -319,15 +319,15 @@ done:
             ID3D11VideoDecoderOutputView_GetDesc( src, &viewDesc );
 
             D3D11_TEXTURE2D_DESC dstDesc;
-            ID3D11Texture2D_GetDesc( p_sys_out->texture, &dstDesc);
+            ID3D11Texture2D_GetDesc( p_sys_out->texture[KNOWN_DXGI_INDEX], &dstDesc);
 
             /* copy decoder slice to surface */
             D3D11_BOX copyBox = {
                 .right = dstDesc.Width, .bottom = dstDesc.Height, .back = 1,
             };
-            ID3D11DeviceContext_CopySubresourceRegion(sys->d3dctx, p_sys_out->resource,
+            ID3D11DeviceContext_CopySubresourceRegion(sys->d3dctx, p_sys_out->resource[KNOWN_DXGI_INDEX],
                                                       p_sys_out->slice_index, 0, 0, 0,
-                                                      p_sys_in->resource,
+                                                      p_sys_in->resource[KNOWN_DXGI_INDEX],
                                                       viewDesc.Texture2D.ArraySlice,
                                                       &copyBox);
             if( sys->context_mutex  != INVALID_HANDLE_VALUE ) {
@@ -386,7 +386,7 @@ static int Get(vlc_va_t *va, picture_t *pic, uint8_t **data)
         viewDesc.Texture2D.ArraySlice = p_sys->slice_index;
 
         hr = ID3D11VideoDevice_CreateVideoDecoderOutputView( (ID3D11VideoDevice*) dx_sys->d3ddec,
-                                                             (ID3D11Resource*) p_sys->texture,
+                                                             p_sys->resource[KNOWN_DXGI_INDEX],
                                                              &viewDesc,
                                                              &p_sys->decoder );
         if (FAILED(hr)) {
@@ -494,9 +494,9 @@ static int Open(vlc_va_t *va, AVCodecContext *ctx, enum PixelFormat pix_fmt,
             sys->d3dvidctx = d3dvidctx;
             sys->b_extern_pool = true;
 
-            assert(p_sys->texture != NULL);
+            assert(p_sys->texture[KNOWN_DXGI_INDEX] != NULL);
             D3D11_TEXTURE2D_DESC dstDesc;
-            ID3D11Texture2D_GetDesc( p_sys->texture, &dstDesc);
+            ID3D11Texture2D_GetDesc( p_sys->texture[KNOWN_DXGI_INDEX], &dstDesc);
             sys->render = dstDesc.Format;
         }
     }
@@ -1026,7 +1026,7 @@ static int DxCreateDecoderSurfaces(vlc_va_t *va, int codec_id, const video_forma
             }
 
             D3D11_TEXTURE2D_DESC texDesc;
-            ID3D11Texture2D_GetDesc(pic->p_sys->texture, &texDesc);
+            ID3D11Texture2D_GetDesc(pic->p_sys->texture[KNOWN_DXGI_INDEX], &texDesc);
             if (texDesc.ArraySize < dx_sys->surface_count)
             {
                 msg_Warn(va, "not enough decoding slices in the texture (%d/%d)",
@@ -1049,7 +1049,7 @@ static int DxCreateDecoderSurfaces(vlc_va_t *va, int codec_id, const video_forma
 
             viewDesc.Texture2D.ArraySlice = pic->p_sys->slice_index;
             hr = ID3D11VideoDevice_CreateVideoDecoderOutputView( (ID3D11VideoDevice*) dx_sys->d3ddec,
-                                                                 pic->p_sys->resource,
+                                                                 pic->p_sys->resource[KNOWN_DXGI_INDEX],
                                                                  &viewDesc,
                                                                  &pic->p_sys->decoder );
             if (FAILED(hr)) {
@@ -1208,7 +1208,7 @@ static void DxDestroySurfaces(vlc_va_t *va)
 static void DestroyPicture(picture_t *picture)
 {
     picture_sys_t *p_sys = picture->p_sys;
-    ID3D11Texture2D_Release( p_sys->texture );
+    ID3D11Texture2D_Release( p_sys->texture[KNOWN_DXGI_INDEX] );
     if (p_sys->inputView)
         ID3D11View_Release( (ID3D11View*) p_sys->inputView );
 
@@ -1229,7 +1229,7 @@ static picture_t *DxAllocPicture(vlc_va_t *va, const video_format_t *fmt, unsign
         return NULL;
 
     pic_sys->decoder  = (ID3D11VideoDecoderOutputView*) sys->dx_sys.hw_surface[index];
-    ID3D11VideoDecoderOutputView_GetResource(pic_sys->decoder, &pic_sys->resource);
+    ID3D11VideoDecoderOutputView_GetResource(pic_sys->decoder, &pic_sys->resource[KNOWN_DXGI_INDEX]);
     pic_sys->context  = sys->d3dctx;
 
     if (sys->procEnumerator)
@@ -1242,7 +1242,7 @@ static picture_t *DxAllocPicture(vlc_va_t *va, const video_format_t *fmt, unsign
         };
 
         HRESULT hr = ID3D11VideoDevice_CreateVideoProcessorInputView((ID3D11VideoDevice*) sys->dx_sys.d3ddec,
-                                                        pic_sys->resource,
+                                                        pic_sys->resource[KNOWN_DXGI_INDEX],
                                                         sys->procEnumerator,
                                                         &inDesc,
                                                         &pic_sys->inputView);
diff --git a/modules/video_chroma/d3d11_fmt.h b/modules/video_chroma/d3d11_fmt.h
index 354a4bc..18f7ae4 100644
--- a/modules/video_chroma/d3d11_fmt.h
+++ b/modules/video_chroma/d3d11_fmt.h
@@ -32,8 +32,8 @@ struct picture_sys_t
 {
     ID3D11VideoDecoderOutputView  *decoder; /* may be NULL for pictures from the pool */
     union {
-        ID3D11Texture2D           *texture;
-        ID3D11Resource            *resource;
+        ID3D11Texture2D           *texture[D3D11_MAX_SHADER_VIEW];
+        ID3D11Resource            *resource[D3D11_MAX_SHADER_VIEW];
     };
     ID3D11DeviceContext           *context;
     unsigned                      slice_index;
@@ -41,4 +41,8 @@ struct picture_sys_t
     ID3D11ShaderResourceView      *resourceView[D3D11_MAX_SHADER_VIEW];
 };
 
+/* index to use for texture/resource that use a known DXGI format
+ * (ie not DXGI_FORMAT_UNKNWON) */
+#define KNOWN_DXGI_INDEX   0
+
 #endif /* include-guard */
diff --git a/modules/video_chroma/d3d11_surface.c b/modules/video_chroma/d3d11_surface.c
index 65227a3..36974d8 100644
--- a/modules/video_chroma/d3d11_surface.c
+++ b/modules/video_chroma/d3d11_surface.c
@@ -70,7 +70,7 @@ static int assert_staging(filter_t *p_filter, picture_sys_t *p_sys)
         goto ok;
 
     D3D11_TEXTURE2D_DESC texDesc;
-    ID3D11Texture2D_GetDesc( p_sys->texture, &texDesc);
+    ID3D11Texture2D_GetDesc( p_sys->texture[KNOWN_DXGI_INDEX], &texDesc);
 
     texDesc.MipLevels = 1;
     //texDesc.SampleDesc.Count = 1;
@@ -113,7 +113,8 @@ static void D3D11_YUY2(filter_t *p_filter, picture_t *src, picture_t *dst)
 
     ID3D11DeviceContext_CopySubresourceRegion(p_sys->context, sys->staging_resource,
                                               0, 0, 0, 0,
-                                              p_sys->resource, viewDesc.Texture2D.ArraySlice,
+                                              p_sys->resource[KNOWN_DXGI_INDEX],
+                                              viewDesc.Texture2D.ArraySlice,
                                               NULL);
 
     HRESULT hr = ID3D11DeviceContext_Map(p_sys->context, sys->staging_resource,
@@ -194,7 +195,8 @@ static void D3D11_NV12(filter_t *p_filter, picture_t *src, picture_t *dst)
 
     ID3D11DeviceContext_CopySubresourceRegion(p_sys->context, sys->staging_resource,
                                               0, 0, 0, 0,
-                                              p_sys->resource, viewDesc.Texture2D.ArraySlice,
+                                              p_sys->resource[KNOWN_DXGI_INDEX],
+                                              viewDesc.Texture2D.ArraySlice,
                                               NULL);
 
     HRESULT hr = ID3D11DeviceContext_Map(p_sys->context, sys->staging_resource,
diff --git a/modules/video_output/win32/direct3d11.c b/modules/video_output/win32/direct3d11.c
index 9630b88..21be0ac 100644
--- a/modules/video_output/win32/direct3d11.c
+++ b/modules/video_output/win32/direct3d11.c
@@ -112,7 +112,7 @@ typedef struct
     UINT                      indexCount;
     ID3D11Buffer              *pVertexShaderConstants;
     picture_sys_t             picSys;
-    ID3D11Texture2D           *pTexture;
+    ID3D11Texture2D           *pTexture[D3D11_MAX_SHADER_VIEW];
     ID3D11Buffer              *pPixelShaderConstants[2];
     UINT                       PSConstantsCount;
     ID3D11PixelShader         *d3dpixelShader;
@@ -617,14 +617,14 @@ static const d3d_format_t *GetOutputFormat(vout_display_t *vd, vlc_fourcc_t i_sr
 }
 
 /* map texture planes to resource views */
-static int AllocateShaderView(vout_display_t *vd, const d3d_format_t *format, ID3D11Texture2D *texture,
+static int AllocateShaderView(vout_display_t *vd, const d3d_format_t *format, ID3D11Texture2D *texture[D3D11_MAX_SHADER_VIEW],
                               int slice_index, ID3D11ShaderResourceView *resourceView[2])
 {
     HRESULT hr;
     vout_display_sys_t *sys = vd->sys;
-    D3D11_SHADER_RESOURCE_VIEW_DESC resviewDesc = {
-        .Format = format->resourceFormat[0],
-    };
+    int i;
+    D3D11_SHADER_RESOURCE_VIEW_DESC resviewDesc = { 0 };
+
     if (sys->legacy_shader)
     {
         resviewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
@@ -638,31 +638,33 @@ static int AllocateShaderView(vout_display_t *vd, const d3d_format_t *format, ID
         resviewDesc.Texture2DArray.FirstArraySlice = slice_index;
     }
 
-    hr = ID3D11Device_CreateShaderResourceView(sys->d3ddevice, (ID3D11Resource *)texture, &resviewDesc, &resourceView[0]);
-    if (FAILED(hr)) {
-        msg_Err(vd, "Could not Create the Y/RGB Texture ResourceView slice %d. (hr=0x%lX)", slice_index, hr);
-        goto error;
+    for (i=0; i<D3D11_MAX_SHADER_VIEW; i++)
+    {
+        if (!texture[i])
+            resourceView[i] = NULL;
+        else
+        {
+            resviewDesc.Format = format->resourceFormat[i];
+            hr = ID3D11Device_CreateShaderResourceView(sys->d3ddevice, (ID3D11Resource *)texture[i], &resviewDesc, &resourceView[i]);
+            if (FAILED(hr)) {
+                msg_Err(vd, "Could not Create the Texture ResourceView %d slice %d. (hr=0x%lX)", i, slice_index, hr);
+                break;
+            }
+        }
     }
 
-    resourceView[1] = NULL;
-    if( format->resourceFormat[1] )
+    if (i != D3D11_MAX_SHADER_VIEW)
     {
-        resviewDesc.Format = format->resourceFormat[1];
-        hr = ID3D11Device_CreateShaderResourceView(sys->d3ddevice, (ID3D11Resource *)texture, &resviewDesc, &resourceView[1]);
-        if (FAILED(hr)) {
-            msg_Err(vd, "Could not Create the UV Texture ResourceView slice %d. (hr=0x%lX)", slice_index, hr);
-            goto error;
+        while (i >= 0)
+        {
+            ID3D11ShaderResourceView_Release(resourceView[i]);
+            resourceView[i] = NULL;
+            i--;
         }
+        return VLC_EGENERIC;
     }
 
     return VLC_SUCCESS;
-error:
-    if (resourceView[0]) {
-        ID3D11ShaderResourceView_Release(resourceView[0]);
-        resourceView[0] = NULL;
-    }
-    resourceView[1] = NULL;
-    return VLC_EGENERIC;
 }
 
 static picture_pool_t *Pool(vout_display_t *vd, unsigned pool_size)
@@ -673,6 +675,7 @@ static picture_pool_t *Pool(vout_display_t *vd, unsigned pool_size)
 #ifdef HAVE_ID3D11VIDEODECODER
     picture_t**       pictures = NULL;
     unsigned          picture_count = 0;
+    unsigned          plane;
     HRESULT           hr;
 
     const d3d_format_t *cfg = GetOutputFormat(vd, vd->fmt.i_chroma, 0, true, false);
@@ -716,11 +719,22 @@ static picture_pool_t *Pool(vout_display_t *vd, unsigned pool_size)
             goto error;
 
         ID3D11Texture2D_AddRef(texture);
-        picsys->texture = texture;
+        picsys->texture[KNOWN_DXGI_INDEX] = texture;
         picsys->slice_index = picture_count;
         picsys->context = vd->sys->d3dcontext;
 
-        if (AllocateShaderView(vd, vd->sys->picQuadConfig, texture, picture_count, picsys->resourceView) != VLC_SUCCESS)
+        plane = KNOWN_DXGI_INDEX + 1;
+        for (; plane < D3D11_MAX_SHADER_VIEW; plane++) {
+            if (!vd->sys->picQuadConfig->resourceFormat[plane])
+                picsys->texture[plane] = NULL;
+            else
+            {
+                picsys->texture[plane] = picsys->texture[KNOWN_DXGI_INDEX];
+                ID3D11Texture2D_AddRef(picsys->texture[plane]);
+            }
+        }
+
+        if (AllocateShaderView(vd, vd->sys->picQuadConfig, picsys->texture, picture_count, picsys->resourceView) != VLC_SUCCESS)
             goto error;
 
         picture_resource_t resource = {
@@ -777,9 +791,9 @@ static void DestroyDisplayPoolPicture(picture_t *picture)
     for (int i=0; i<D3D11_MAX_SHADER_VIEW; i++) {
         if (p_sys->resourceView[i])
             ID3D11ShaderResourceView_Release(p_sys->resourceView[i]);
+        if (p_sys->texture[i])
+            ID3D11Texture2D_Release(p_sys->texture[i]);
     }
-    if (p_sys->texture)
-        ID3D11Texture2D_Release(p_sys->texture);
     if (p_sys->context)
         ID3D11DeviceContext_Release(p_sys->context);
 
@@ -1090,9 +1104,9 @@ static void Prepare(vout_display_t *vd, picture_t *picture, subpicture_t *subpic
             WaitForSingleObjectEx( sys->context_lock, INFINITE, FALSE );
         }
         ID3D11DeviceContext_CopySubresourceRegion(sys->d3dcontext,
-                                                  (ID3D11Resource*) sys->picQuad.pTexture,
+                                                  (ID3D11Resource*) sys->picQuad.pTexture[KNOWN_DXGI_INDEX],
                                                   0, 0, 0, 0,
-                                                  p_sys->resource,
+                                                  p_sys->resource[KNOWN_DXGI_INDEX],
                                                   p_sys->slice_index, NULL);
         if ( sys->context_lock != INVALID_HANDLE_VALUE)
             ReleaseMutex( sys->context_lock );
@@ -1748,7 +1762,7 @@ static int Direct3D11CreatePool(vout_display_t *vd, video_format_t *fmt)
     if (unlikely(poolsys == NULL)) {
         return VLC_ENOMEM;
     }
-    poolsys->texture  = sys->picQuad.pTexture;
+    poolsys->texture  = sys->picQuad.pTexture[KNOWN_DXGI_INDEX];
     poolsys->vd       = vd;
 
     picture_resource_t resource = {
@@ -2119,18 +2133,27 @@ static int AllocQuad(vout_display_t *vd, const video_format_t *fmt, d3d_quad_t *
         texDesc.Height &= ~1;
     }
 
-    hr = ID3D11Device_CreateTexture2D(sys->d3ddevice, &texDesc, NULL, &quad->pTexture);
+    hr = ID3D11Device_CreateTexture2D(sys->d3ddevice, &texDesc, NULL, &quad->pTexture[KNOWN_DXGI_INDEX]);
     if (FAILED(hr)) {
         msg_Err(vd, "Could not Create the D3d11 Texture. (hr=0x%lX)", hr);
         goto error;
     }
+    for (int i=KNOWN_DXGI_INDEX+1; i<D3D11_MAX_SHADER_VIEW; i++) {
+        if (!cfg->resourceFormat[i])
+            quad->pTexture[i] = NULL;
+        else
+        {
+            quad->pTexture[i] = quad->pTexture[KNOWN_DXGI_INDEX];
+            ID3D11Texture2D_AddRef(quad->pTexture[i]);
+        }
+    }
 
-    hr = ID3D11DeviceContext_Map(sys->d3dcontext, (ID3D11Resource *)quad->pTexture, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
+    hr = ID3D11DeviceContext_Map(sys->d3dcontext, (ID3D11Resource *)quad->pTexture[KNOWN_DXGI_INDEX], 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
     if( FAILED(hr) ) {
         msg_Err(vd, "The texture cannot be mapped. (hr=0x%lX)", hr);
         goto error;
     }
-    ID3D11DeviceContext_Unmap(sys->d3dcontext, (ID3D11Resource *)quad->pTexture, 0);
+    ID3D11DeviceContext_Unmap(sys->d3dcontext, (ID3D11Resource *)quad->pTexture[KNOWN_DXGI_INDEX], 0);
     if (mappedResource.RowPitch < p_chroma_desc->pixel_size * texDesc.Width) {
         msg_Err( vd, "The texture row pitch is too small (%d instead of %d)", mappedResource.RowPitch,
                  p_chroma_desc->pixel_size * texDesc.Width );
@@ -2189,12 +2212,12 @@ static void ReleaseQuad(d3d_quad_t *quad)
         ID3D11Buffer_Release(quad->pVertexShaderConstants);
         quad->pVertexShaderConstants = NULL;
     }
-    if (quad->pTexture)
-    {
-        ID3D11Texture2D_Release(quad->pTexture);
-        quad->pTexture = NULL;
-    }
     for (int i=0; i<D3D11_MAX_SHADER_VIEW; i++) {
+        if (quad->pTexture[i])
+        {
+            ID3D11Texture2D_Release(quad->pTexture[i]);
+            quad->pTexture[i] = NULL;
+        }
         if (quad->picSys.resourceView[i])
         {
             ID3D11ShaderResourceView_Release(quad->picSys.resourceView[i]);
@@ -2338,7 +2361,7 @@ static int Direct3D11MapSubpicture(vout_display_t *vd, int *subpicture_region_co
         for (int j = 0; j < sys->d3dregion_count; j++) {
             picture_t *cache = sys->d3dregions[j];
             if (cache != NULL && ((d3d_quad_t *) cache->p_sys)->pTexture) {
-                ID3D11Texture2D_GetDesc( ((d3d_quad_t *) cache->p_sys)->pTexture, &texDesc );
+                ID3D11Texture2D_GetDesc( ((d3d_quad_t *) cache->p_sys)->pTexture[KNOWN_DXGI_INDEX], &texDesc );
                 if (texDesc.Format == sys->d3dregion_format->formatTexture &&
                     texDesc.Width  == r->fmt.i_visible_width &&
                     texDesc.Height == r->fmt.i_visible_height) {
@@ -2377,7 +2400,7 @@ static int Direct3D11MapSubpicture(vout_display_t *vd, int *subpicture_region_co
             quad_picture = (*region)[i];
         }
 
-        hr = ID3D11DeviceContext_Map(sys->d3dcontext, (ID3D11Resource *)((d3d_quad_t *) quad_picture->p_sys)->pTexture, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
+        hr = ID3D11DeviceContext_Map(sys->d3dcontext, (ID3D11Resource *)((d3d_quad_t *) quad_picture->p_sys)->pTexture[KNOWN_DXGI_INDEX], 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
         if( SUCCEEDED(hr) ) {
             err = CommonUpdatePicture(quad_picture, NULL, mappedResource.pData, mappedResource.RowPitch);
             if (err != VLC_SUCCESS) {
@@ -2388,7 +2411,7 @@ static int Direct3D11MapSubpicture(vout_display_t *vd, int *subpicture_region_co
 
             picture_CopyPixels(quad_picture, r->p_picture);
 
-            ID3D11DeviceContext_Unmap(sys->d3dcontext, (ID3D11Resource *)((d3d_quad_t *) quad_picture->p_sys)->pTexture, 0);
+            ID3D11DeviceContext_Unmap(sys->d3dcontext, (ID3D11Resource *)((d3d_quad_t *) quad_picture->p_sys)->pTexture[KNOWN_DXGI_INDEX], 0);
         } else {
             msg_Err(vd, "Failed to map the SPU texture (hr=0x%lX)", hr );
             picture_Release(quad_picture);
-- 
2.10.1.windows.1

