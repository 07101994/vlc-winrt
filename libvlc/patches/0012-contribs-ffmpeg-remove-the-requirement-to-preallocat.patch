From 7e4f6f3313790742c9d30c049e0aa7ad9edbbce6 Mon Sep 17 00:00:00 2001
From: Steve Lhomme <slhomme@matroska.org>
Date: Fri, 2 Dec 2016 09:51:46 +0100
Subject: [PATCH 12/21] contribs: ffmpeg: remove the requirement to preallocate
 d3d11va surfaces

---
 ...-single-macro-to-test-if-the-DXVA-context.patch | 107 ++++++++++++++++++
 ...-macro-to-test-if-the-DXVA-context.patch.ffmpeg | 123 +++++++++++++++++++++
 ...he-slice-number-directly-from-the-surface.patch |  48 ++++++++
 ...e-number-directly-from-the-surface.patch.ffmpeg |  49 ++++++++
 ...-an-empty-array-of-ID3D11VideoDecoderOutp.patch |  51 +++++++++
 ...ty-array-of-ID3D11VideoDecoderOutp.patch.ffmpeg |  51 +++++++++
 contrib/src/ffmpeg/rules.mak                       |   6 +-
 7 files changed, 434 insertions(+), 1 deletion(-)
 create mode 100644 contrib/src/ffmpeg/0001-dxva2-use-a-single-macro-to-test-if-the-DXVA-context.patch
 create mode 100644 contrib/src/ffmpeg/0001-dxva2-use-a-single-macro-to-test-if-the-DXVA-context.patch.ffmpeg
 create mode 100644 contrib/src/ffmpeg/0002-dxva2-get-the-slice-number-directly-from-the-surface.patch
 create mode 100644 contrib/src/ffmpeg/0002-dxva2-get-the-slice-number-directly-from-the-surface.patch.ffmpeg
 create mode 100644 contrib/src/ffmpeg/0003-dxva2-allow-an-empty-array-of-ID3D11VideoDecoderOutp.patch
 create mode 100644 contrib/src/ffmpeg/0003-dxva2-allow-an-empty-array-of-ID3D11VideoDecoderOutp.patch.ffmpeg

diff --git a/contrib/src/ffmpeg/0001-dxva2-use-a-single-macro-to-test-if-the-DXVA-context.patch b/contrib/src/ffmpeg/0001-dxva2-use-a-single-macro-to-test-if-the-DXVA-context.patch
new file mode 100644
index 0000000..fad6d9e
--- /dev/null
+++ b/contrib/src/ffmpeg/0001-dxva2-use-a-single-macro-to-test-if-the-DXVA-context.patch
@@ -0,0 +1,107 @@
+From 36010d8f9e2c9c56022fb9e276eb2f7731336674 Mon Sep 17 00:00:00 2001
+From: Steve Lhomme <slhomme@matroska.org>
+Date: Thu, 1 Dec 2016 17:37:15 +0100
+Subject: [PATCH 1/3] dxva2: use a single macro to test if the DXVA context is
+ valid
+
+---
+ libavcodec/dxva2_h264.c     | 4 +---
+ libavcodec/dxva2_hevc.c     | 4 +---
+ libavcodec/dxva2_internal.h | 5 +++++
+ libavcodec/dxva2_mpeg2.c    | 4 +---
+ libavcodec/dxva2_vc1.c      | 4 +---
+ 5 files changed, 9 insertions(+), 12 deletions(-)
+
+diff --git a/libavcodec/dxva2_h264.c b/libavcodec/dxva2_h264.c
+index 5622c22..84959c5 100644
+--- a/libavcodec/dxva2_h264.c
++++ b/libavcodec/dxva2_h264.c
+@@ -445,9 +445,7 @@ static int dxva2_h264_start_frame(AVCodecContext *avctx,
+     AVDXVAContext *ctx = avctx->hwaccel_context;
+     struct dxva2_picture_context *ctx_pic = h->cur_pic_ptr->hwaccel_picture_private;
+ 
+-    if (DXVA_CONTEXT_DECODER(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_CFG(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_COUNT(avctx, ctx) <= 0)
++    if (!DXVA_CONTEXT_VALID(avctx, ctx))
+         return -1;
+     assert(ctx_pic);
+ 
+diff --git a/libavcodec/dxva2_hevc.c b/libavcodec/dxva2_hevc.c
+index 673fada..17548d2 100644
+--- a/libavcodec/dxva2_hevc.c
++++ b/libavcodec/dxva2_hevc.c
+@@ -365,9 +365,7 @@ static int dxva2_hevc_start_frame(AVCodecContext *avctx,
+     AVDXVAContext *ctx = avctx->hwaccel_context;
+     struct hevc_dxva2_picture_context *ctx_pic = h->ref->hwaccel_picture_private;
+ 
+-    if (DXVA_CONTEXT_DECODER(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_CFG(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_COUNT(avctx, ctx) <= 0)
++    if (!DXVA_CONTEXT_VALID(avctx, ctx))
+         return -1;
+     av_assert0(ctx_pic);
+ 
+diff --git a/libavcodec/dxva2_internal.h b/libavcodec/dxva2_internal.h
+index 766af0b..43c7912 100644
+--- a/libavcodec/dxva2_internal.h
++++ b/libavcodec/dxva2_internal.h
+@@ -75,6 +75,9 @@ typedef union {
+ #define DXVA_CONTEXT_CFG_BITSTREAM(avctx, ctx)  (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD ? ctx->d3d11va.cfg->ConfigBitstreamRaw : ctx->dxva2.cfg->ConfigBitstreamRaw)
+ #define DXVA_CONTEXT_CFG_INTRARESID(avctx, ctx) (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD ? ctx->d3d11va.cfg->ConfigIntraResidUnsigned : ctx->dxva2.cfg->ConfigIntraResidUnsigned)
+ #define DXVA_CONTEXT_CFG_RESIDACCEL(avctx, ctx) (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD ? ctx->d3d11va.cfg->ConfigResidDiffAccelerator : ctx->dxva2.cfg->ConfigResidDiffAccelerator)
++#define DXVA_CONTEXT_VALID(avctx, ctx)          (DXVA_CONTEXT_DECODER(avctx, ctx) && \
++                                                 DXVA_CONTEXT_CFG(avctx, ctx) && \
++                                                 DXVA_CONTEXT_COUNT(avctx, ctx))
+ #elif CONFIG_DXVA2
+ #define DXVA_CONTEXT_WORKAROUND(avctx, ctx)     (ctx->dxva2.workaround)
+ #define DXVA_CONTEXT_COUNT(avctx, ctx)          (ctx->dxva2.surface_count)
+@@ -84,6 +87,7 @@ typedef union {
+ #define DXVA_CONTEXT_CFG_BITSTREAM(avctx, ctx)  (ctx->dxva2.cfg->ConfigBitstreamRaw)
+ #define DXVA_CONTEXT_CFG_INTRARESID(avctx, ctx) (ctx->dxva2.cfg->ConfigIntraResidUnsigned)
+ #define DXVA_CONTEXT_CFG_RESIDACCEL(avctx, ctx) (ctx->dxva2.cfg->ConfigResidDiffAccelerator)
++#define DXVA_CONTEXT_VALID(avctx, ctx)          (ctx->dxva2.decoder && ctx->dxva2.cfg && ctx->dxva2.surface_count)
+ #elif CONFIG_D3D11VA
+ #define DXVA_CONTEXT_WORKAROUND(avctx, ctx)     (ctx->d3d11va.workaround)
+ #define DXVA_CONTEXT_COUNT(avctx, ctx)          (ctx->d3d11va.surface_count)
+@@ -93,6 +97,7 @@ typedef union {
+ #define DXVA_CONTEXT_CFG_BITSTREAM(avctx, ctx)  (ctx->d3d11va.cfg->ConfigBitstreamRaw)
+ #define DXVA_CONTEXT_CFG_INTRARESID(avctx, ctx) (ctx->d3d11va.cfg->ConfigIntraResidUnsigned)
+ #define DXVA_CONTEXT_CFG_RESIDACCEL(avctx, ctx) (ctx->d3d11va.cfg->ConfigResidDiffAccelerator)
++#define DXVA_CONTEXT_VALID(avctx, ctx)          (ctx->d3d11va.decoder && ctx->d3d11va.cfg && ctx->d3d11va.surface_count)
+ #endif
+ 
+ unsigned ff_dxva2_get_surface_index(const AVCodecContext *avctx,
+diff --git a/libavcodec/dxva2_mpeg2.c b/libavcodec/dxva2_mpeg2.c
+index 2d88f9b..a459049 100644
+--- a/libavcodec/dxva2_mpeg2.c
++++ b/libavcodec/dxva2_mpeg2.c
+@@ -263,9 +263,7 @@ static int dxva2_mpeg2_start_frame(AVCodecContext *avctx,
+     struct dxva2_picture_context *ctx_pic =
+         s->current_picture_ptr->hwaccel_picture_private;
+ 
+-    if (DXVA_CONTEXT_DECODER(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_CFG(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_COUNT(avctx, ctx) <= 0)
++    if (!DXVA_CONTEXT_VALID(avctx, ctx))
+         return -1;
+     assert(ctx_pic);
+ 
+diff --git a/libavcodec/dxva2_vc1.c b/libavcodec/dxva2_vc1.c
+index d170e18..0672c97 100644
+--- a/libavcodec/dxva2_vc1.c
++++ b/libavcodec/dxva2_vc1.c
+@@ -264,9 +264,7 @@ static int dxva2_vc1_start_frame(AVCodecContext *avctx,
+     AVDXVAContext *ctx = avctx->hwaccel_context;
+     struct dxva2_picture_context *ctx_pic = v->s.current_picture_ptr->hwaccel_picture_private;
+ 
+-    if (DXVA_CONTEXT_DECODER(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_CFG(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_COUNT(avctx, ctx) <= 0)
++    if (!DXVA_CONTEXT_VALID(avctx, ctx))
+         return -1;
+     assert(ctx_pic);
+ 
+-- 
+2.10.1.windows.1
+
diff --git a/contrib/src/ffmpeg/0001-dxva2-use-a-single-macro-to-test-if-the-DXVA-context.patch.ffmpeg b/contrib/src/ffmpeg/0001-dxva2-use-a-single-macro-to-test-if-the-DXVA-context.patch.ffmpeg
new file mode 100644
index 0000000..03972a5
--- /dev/null
+++ b/contrib/src/ffmpeg/0001-dxva2-use-a-single-macro-to-test-if-the-DXVA-context.patch.ffmpeg
@@ -0,0 +1,123 @@
+From 24347cf043a8d53266931e4c5d18dc9fa7dca23f Mon Sep 17 00:00:00 2001
+From: Steve Lhomme <slhomme@matroska.org>
+Date: Thu, 1 Dec 2016 17:02:05 +0100
+Subject: [PATCH 1/3] dxva2: use a single macro to test if the DXVA context is
+ valid
+
+---
+ libavcodec/dxva2_h264.c     | 4 +---
+ libavcodec/dxva2_hevc.c     | 4 +---
+ libavcodec/dxva2_internal.h | 5 +++++
+ libavcodec/dxva2_mpeg2.c    | 4 +---
+ libavcodec/dxva2_vc1.c      | 4 +---
+ libavcodec/dxva2_vp9.c      | 4 +---
+ 6 files changed, 10 insertions(+), 15 deletions(-)
+
+diff --git a/libavcodec/dxva2_h264.c b/libavcodec/dxva2_h264.c
+index 82a772d..59fa5e3 100644
+--- a/libavcodec/dxva2_h264.c
++++ b/libavcodec/dxva2_h264.c
+@@ -450,9 +450,7 @@ static int dxva2_h264_start_frame(AVCodecContext *avctx,
+     AVDXVAContext *ctx = avctx->hwaccel_context;
+     struct dxva2_picture_context *ctx_pic = h->cur_pic_ptr->hwaccel_picture_private;
+ 
+-    if (DXVA_CONTEXT_DECODER(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_CFG(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_COUNT(avctx, ctx) <= 0)
++    if (!DXVA_CONTEXT_VALID(avctx, ctx))
+         return -1;
+     assert(ctx_pic);
+ 
+diff --git a/libavcodec/dxva2_hevc.c b/libavcodec/dxva2_hevc.c
+index 5a312ea..981c888 100644
+--- a/libavcodec/dxva2_hevc.c
++++ b/libavcodec/dxva2_hevc.c
+@@ -364,9 +364,7 @@ static int dxva2_hevc_start_frame(AVCodecContext *avctx,
+     AVDXVAContext *ctx = avctx->hwaccel_context;
+     struct hevc_dxva2_picture_context *ctx_pic = h->ref->hwaccel_picture_private;
+ 
+-    if (DXVA_CONTEXT_DECODER(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_CFG(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_COUNT(avctx, ctx) <= 0)
++    if (!DXVA_CONTEXT_VALID(avctx, ctx))
+         return -1;
+     av_assert0(ctx_pic);
+ 
+diff --git a/libavcodec/dxva2_internal.h b/libavcodec/dxva2_internal.h
+index c962810..e5322ef 100644
+--- a/libavcodec/dxva2_internal.h
++++ b/libavcodec/dxva2_internal.h
+@@ -76,6 +76,9 @@ typedef union {
+ #define DXVA_CONTEXT_CFG_BITSTREAM(avctx, ctx)  (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD ? ctx->d3d11va.cfg->ConfigBitstreamRaw : ctx->dxva2.cfg->ConfigBitstreamRaw)
+ #define DXVA_CONTEXT_CFG_INTRARESID(avctx, ctx) (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD ? ctx->d3d11va.cfg->ConfigIntraResidUnsigned : ctx->dxva2.cfg->ConfigIntraResidUnsigned)
+ #define DXVA_CONTEXT_CFG_RESIDACCEL(avctx, ctx) (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD ? ctx->d3d11va.cfg->ConfigResidDiffAccelerator : ctx->dxva2.cfg->ConfigResidDiffAccelerator)
++#define DXVA_CONTEXT_VALID(avctx, ctx)          (DXVA_CONTEXT_DECODER(avctx, ctx) && \
++                                                 DXVA_CONTEXT_CFG(avctx, ctx) && \
++                                                 DXVA_CONTEXT_COUNT(avctx, ctx))
+ #elif CONFIG_DXVA2
+ #define DXVA_CONTEXT_WORKAROUND(avctx, ctx)     (ctx->dxva2.workaround)
+ #define DXVA_CONTEXT_COUNT(avctx, ctx)          (ctx->dxva2.surface_count)
+@@ -85,6 +88,7 @@ typedef union {
+ #define DXVA_CONTEXT_CFG_BITSTREAM(avctx, ctx)  (ctx->dxva2.cfg->ConfigBitstreamRaw)
+ #define DXVA_CONTEXT_CFG_INTRARESID(avctx, ctx) (ctx->dxva2.cfg->ConfigIntraResidUnsigned)
+ #define DXVA_CONTEXT_CFG_RESIDACCEL(avctx, ctx) (ctx->dxva2.cfg->ConfigResidDiffAccelerator)
++#define DXVA_CONTEXT_VALID(avctx, ctx)          (ctx->dxva2.decoder && ctx->dxva2.cfg && ctx->dxva2.surface_count)
+ #elif CONFIG_D3D11VA
+ #define DXVA_CONTEXT_WORKAROUND(avctx, ctx)     (ctx->d3d11va.workaround)
+ #define DXVA_CONTEXT_COUNT(avctx, ctx)          (ctx->d3d11va.surface_count)
+@@ -94,6 +98,7 @@ typedef union {
+ #define DXVA_CONTEXT_CFG_BITSTREAM(avctx, ctx)  (ctx->d3d11va.cfg->ConfigBitstreamRaw)
+ #define DXVA_CONTEXT_CFG_INTRARESID(avctx, ctx) (ctx->d3d11va.cfg->ConfigIntraResidUnsigned)
+ #define DXVA_CONTEXT_CFG_RESIDACCEL(avctx, ctx) (ctx->d3d11va.cfg->ConfigResidDiffAccelerator)
++#define DXVA_CONTEXT_VALID(avctx, ctx)          (ctx->d3d11va.decoder && ctx->d3d11va.cfg && ctx->d3d11va.surface_count)
+ #endif
+ 
+ unsigned ff_dxva2_get_surface_index(const AVCodecContext *avctx,
+diff --git a/libavcodec/dxva2_mpeg2.c b/libavcodec/dxva2_mpeg2.c
+index c2f0b58..14ac48f 100644
+--- a/libavcodec/dxva2_mpeg2.c
++++ b/libavcodec/dxva2_mpeg2.c
+@@ -262,9 +262,7 @@ static int dxva2_mpeg2_start_frame(AVCodecContext *avctx,
+     struct dxva2_picture_context *ctx_pic =
+         s->current_picture_ptr->hwaccel_picture_private;
+ 
+-    if (DXVA_CONTEXT_DECODER(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_CFG(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_COUNT(avctx, ctx) <= 0)
++    if (!DXVA_CONTEXT_VALID(avctx, ctx))
+         return -1;
+     assert(ctx_pic);
+ 
+diff --git a/libavcodec/dxva2_vc1.c b/libavcodec/dxva2_vc1.c
+index 36bf1ba..cc97d7b 100644
+--- a/libavcodec/dxva2_vc1.c
++++ b/libavcodec/dxva2_vc1.c
+@@ -317,9 +317,7 @@ static int dxva2_vc1_start_frame(AVCodecContext *avctx,
+     AVDXVAContext *ctx = avctx->hwaccel_context;
+     struct dxva2_picture_context *ctx_pic = v->s.current_picture_ptr->hwaccel_picture_private;
+ 
+-    if (DXVA_CONTEXT_DECODER(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_CFG(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_COUNT(avctx, ctx) <= 0)
++    if (!DXVA_CONTEXT_VALID(avctx, ctx))
+         return -1;
+     assert(ctx_pic);
+ 
+diff --git a/libavcodec/dxva2_vp9.c b/libavcodec/dxva2_vp9.c
+index 0c4996c..d53b327 100644
+--- a/libavcodec/dxva2_vp9.c
++++ b/libavcodec/dxva2_vp9.c
+@@ -261,9 +261,7 @@ static int dxva2_vp9_start_frame(AVCodecContext *avctx,
+     AVDXVAContext *ctx = avctx->hwaccel_context;
+     struct vp9_dxva2_picture_context *ctx_pic = h->frames[CUR_FRAME].hwaccel_picture_private;
+ 
+-    if (DXVA_CONTEXT_DECODER(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_CFG(avctx, ctx) == NULL ||
+-        DXVA_CONTEXT_COUNT(avctx, ctx) <= 0)
++    if (!DXVA_CONTEXT_VALID(avctx, ctx))
+         return -1;
+     av_assert0(ctx_pic);
+ 
+-- 
+2.10.1.windows.1
+
diff --git a/contrib/src/ffmpeg/0002-dxva2-get-the-slice-number-directly-from-the-surface.patch b/contrib/src/ffmpeg/0002-dxva2-get-the-slice-number-directly-from-the-surface.patch
new file mode 100644
index 0000000..8343b8d
--- /dev/null
+++ b/contrib/src/ffmpeg/0002-dxva2-get-the-slice-number-directly-from-the-surface.patch
@@ -0,0 +1,48 @@
+From 4925bfdc5c0fc0e615b92f85ccae99d25fdf4958 Mon Sep 17 00:00:00 2001
+From: Steve Lhomme <slhomme@matroska.org>
+Date: Thu, 1 Dec 2016 17:38:17 +0100
+Subject: [PATCH 2/3] dxva2: get the slice number directly from the surface in
+ D3D11VA
+
+No need to loop through the known surfaces, we'll use it anyway.
+
+The loop is only done for DXVA2
+---
+ libavcodec/dxva2.c | 15 ++++++++-------
+ 1 file changed, 8 insertions(+), 7 deletions(-)
+
+diff --git a/libavcodec/dxva2.c b/libavcodec/dxva2.c
+index 4d50793..e32f026 100644
+--- a/libavcodec/dxva2.c
++++ b/libavcodec/dxva2.c
+@@ -41,19 +41,20 @@ unsigned ff_dxva2_get_surface_index(const AVCodecContext *avctx,
+     void *surface = ff_dxva2_get_surface(frame);
+     unsigned i;
+ 
+-    for (i = 0; i < DXVA_CONTEXT_COUNT(avctx, ctx); i++) {
+ #if CONFIG_D3D11VA
+-        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD && ctx->d3d11va.surface[i] == surface) {
+-            D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC viewDesc;
+-            ID3D11VideoDecoderOutputView_GetDesc(ctx->d3d11va.surface[i], &viewDesc);
+-            return viewDesc.Texture2D.ArraySlice;
+-        }
++    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)
++    {
++        D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC viewDesc;
++        ID3D11VideoDecoderOutputView_GetDesc((ID3D11VideoDecoderOutputView*) surface, &viewDesc);
++        return viewDesc.Texture2D.ArraySlice;
++    }
+ #endif
+ #if CONFIG_DXVA2
++    for (i = 0; i < DXVA_CONTEXT_COUNT(avctx, ctx); i++) {
+         if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD && ctx->dxva2.surface[i] == surface)
+             return i;
+-#endif
+     }
++#endif
+ 
+     assert(0);
+     return 0;
+-- 
+2.10.1.windows.1
+
diff --git a/contrib/src/ffmpeg/0002-dxva2-get-the-slice-number-directly-from-the-surface.patch.ffmpeg b/contrib/src/ffmpeg/0002-dxva2-get-the-slice-number-directly-from-the-surface.patch.ffmpeg
new file mode 100644
index 0000000..9afa2a2
--- /dev/null
+++ b/contrib/src/ffmpeg/0002-dxva2-get-the-slice-number-directly-from-the-surface.patch.ffmpeg
@@ -0,0 +1,49 @@
+From a105ba8fea1a26cd4b55e2c88dc9b8662b8856ea Mon Sep 17 00:00:00 2001
+From: Steve Lhomme <slhomme@matroska.org>
+Date: Thu, 1 Dec 2016 15:08:22 +0100
+Subject: [PATCH 2/3] dxva2: get the slice number directly from the surface in
+ D3D11VA
+
+No need to loop through the known surfaces, we'll use it anyway.
+
+The loop is only done for DXVA2
+---
+ libavcodec/dxva2.c | 16 ++++++++--------
+ 1 file changed, 8 insertions(+), 8 deletions(-)
+
+diff --git a/libavcodec/dxva2.c b/libavcodec/dxva2.c
+index a64b1b5..459e267 100644
+--- a/libavcodec/dxva2.c
++++ b/libavcodec/dxva2.c
+@@ -41,20 +41,20 @@ unsigned ff_dxva2_get_surface_index(const AVCodecContext *avctx,
+     void *surface = ff_dxva2_get_surface(frame);
+     unsigned i;
+ 
+-    for (i = 0; i < DXVA_CONTEXT_COUNT(avctx, ctx); i++) {
+ #if CONFIG_D3D11VA
+-        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD && ctx->d3d11va.surface[i] == surface)
+-        {
+-            D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC viewDesc;
+-            ID3D11VideoDecoderOutputView_GetDesc(ctx->d3d11va.surface[i], &viewDesc);
+-            return viewDesc.Texture2D.ArraySlice;
+-        }
++    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)
++    {
++        D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC viewDesc;
++        ID3D11VideoDecoderOutputView_GetDesc((ID3D11VideoDecoderOutputView*) surface, &viewDesc);
++        return viewDesc.Texture2D.ArraySlice;
++    }
+ #endif
+ #if CONFIG_DXVA2
++    for (i = 0; i < DXVA_CONTEXT_COUNT(avctx, ctx); i++) {
+         if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD && ctx->dxva2.surface[i] == surface)
+             return i;
+-#endif
+     }
++#endif
+ 
+     assert(0);
+     return 0;
+-- 
+2.10.1.windows.1
+
diff --git a/contrib/src/ffmpeg/0003-dxva2-allow-an-empty-array-of-ID3D11VideoDecoderOutp.patch b/contrib/src/ffmpeg/0003-dxva2-allow-an-empty-array-of-ID3D11VideoDecoderOutp.patch
new file mode 100644
index 0000000..6502879
--- /dev/null
+++ b/contrib/src/ffmpeg/0003-dxva2-allow-an-empty-array-of-ID3D11VideoDecoderOutp.patch
@@ -0,0 +1,51 @@
+From 46c4003a382eb41193f7a55caa390c47fdead461 Mon Sep 17 00:00:00 2001
+From: Steve Lhomme <slhomme@matroska.org>
+Date: Thu, 1 Dec 2016 17:40:19 +0100
+Subject: [PATCH 3/3] dxva2: allow an empty array of
+ ID3D11VideoDecoderOutputView
+
+We can pick the correct slice index directly from the ID3D11VideoDecoderOutputView
+casted from data[3].
+---
+ libavcodec/dxva2_internal.h | 4 ++--
+ libavcodec/version.h        | 2 +-
+ 2 files changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/libavcodec/dxva2_internal.h b/libavcodec/dxva2_internal.h
+index 43c7912..25c1496 100644
+--- a/libavcodec/dxva2_internal.h
++++ b/libavcodec/dxva2_internal.h
+@@ -77,7 +77,7 @@ typedef union {
+ #define DXVA_CONTEXT_CFG_RESIDACCEL(avctx, ctx) (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD ? ctx->d3d11va.cfg->ConfigResidDiffAccelerator : ctx->dxva2.cfg->ConfigResidDiffAccelerator)
+ #define DXVA_CONTEXT_VALID(avctx, ctx)          (DXVA_CONTEXT_DECODER(avctx, ctx) && \
+                                                  DXVA_CONTEXT_CFG(avctx, ctx) && \
+-                                                 DXVA_CONTEXT_COUNT(avctx, ctx))
++                                                 (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD || ctx->dxva2.surface_count))
+ #elif CONFIG_DXVA2
+ #define DXVA_CONTEXT_WORKAROUND(avctx, ctx)     (ctx->dxva2.workaround)
+ #define DXVA_CONTEXT_COUNT(avctx, ctx)          (ctx->dxva2.surface_count)
+@@ -97,7 +97,7 @@ typedef union {
+ #define DXVA_CONTEXT_CFG_BITSTREAM(avctx, ctx)  (ctx->d3d11va.cfg->ConfigBitstreamRaw)
+ #define DXVA_CONTEXT_CFG_INTRARESID(avctx, ctx) (ctx->d3d11va.cfg->ConfigIntraResidUnsigned)
+ #define DXVA_CONTEXT_CFG_RESIDACCEL(avctx, ctx) (ctx->d3d11va.cfg->ConfigResidDiffAccelerator)
+-#define DXVA_CONTEXT_VALID(avctx, ctx)          (ctx->d3d11va.decoder && ctx->d3d11va.cfg && ctx->d3d11va.surface_count)
++#define DXVA_CONTEXT_VALID(avctx, ctx)          (ctx->d3d11va.decoder && ctx->d3d11va.cfg)
+ #endif
+ 
+ unsigned ff_dxva2_get_surface_index(const AVCodecContext *avctx,
+diff --git a/libavcodec/version.h b/libavcodec/version.h
+index 6f58bc8..36adc45 100644
+--- a/libavcodec/version.h
++++ b/libavcodec/version.h
+@@ -29,7 +29,7 @@
+ 
+ #define LIBAVCODEC_VERSION_MAJOR 57
+ #define LIBAVCODEC_VERSION_MINOR 28
+-#define LIBAVCODEC_VERSION_MICRO  4
++#define LIBAVCODEC_VERSION_MICRO  5
+ 
+ #define LIBAVCODEC_VERSION_INT  AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, \
+                                                LIBAVCODEC_VERSION_MINOR, \
+-- 
+2.10.1.windows.1
+
diff --git a/contrib/src/ffmpeg/0003-dxva2-allow-an-empty-array-of-ID3D11VideoDecoderOutp.patch.ffmpeg b/contrib/src/ffmpeg/0003-dxva2-allow-an-empty-array-of-ID3D11VideoDecoderOutp.patch.ffmpeg
new file mode 100644
index 0000000..78daf3c
--- /dev/null
+++ b/contrib/src/ffmpeg/0003-dxva2-allow-an-empty-array-of-ID3D11VideoDecoderOutp.patch.ffmpeg
@@ -0,0 +1,51 @@
+From 55e4c2d53e39672b8747725e5ab7c716a5da63ad Mon Sep 17 00:00:00 2001
+From: Steve Lhomme <slhomme@matroska.org>
+Date: Thu, 1 Dec 2016 17:03:52 +0100
+Subject: [PATCH 3/3] dxva2: allow an empty array of
+ ID3D11VideoDecoderOutputView
+
+We can pick the correct slice index directly from the ID3D11VideoDecoderOutputView
+casted from data[3].
+---
+ libavcodec/dxva2_internal.h | 4 ++--
+ libavcodec/version.h        | 2 +-
+ 2 files changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/libavcodec/dxva2_internal.h b/libavcodec/dxva2_internal.h
+index e5322ef..dfff4d6 100644
+--- a/libavcodec/dxva2_internal.h
++++ b/libavcodec/dxva2_internal.h
+@@ -78,7 +78,7 @@ typedef union {
+ #define DXVA_CONTEXT_CFG_RESIDACCEL(avctx, ctx) (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD ? ctx->d3d11va.cfg->ConfigResidDiffAccelerator : ctx->dxva2.cfg->ConfigResidDiffAccelerator)
+ #define DXVA_CONTEXT_VALID(avctx, ctx)          (DXVA_CONTEXT_DECODER(avctx, ctx) && \
+                                                  DXVA_CONTEXT_CFG(avctx, ctx) && \
+-                                                 DXVA_CONTEXT_COUNT(avctx, ctx))
++                                                 (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD || ctx->dxva2.surface_count))
+ #elif CONFIG_DXVA2
+ #define DXVA_CONTEXT_WORKAROUND(avctx, ctx)     (ctx->dxva2.workaround)
+ #define DXVA_CONTEXT_COUNT(avctx, ctx)          (ctx->dxva2.surface_count)
+@@ -98,7 +98,7 @@ typedef union {
+ #define DXVA_CONTEXT_CFG_BITSTREAM(avctx, ctx)  (ctx->d3d11va.cfg->ConfigBitstreamRaw)
+ #define DXVA_CONTEXT_CFG_INTRARESID(avctx, ctx) (ctx->d3d11va.cfg->ConfigIntraResidUnsigned)
+ #define DXVA_CONTEXT_CFG_RESIDACCEL(avctx, ctx) (ctx->d3d11va.cfg->ConfigResidDiffAccelerator)
+-#define DXVA_CONTEXT_VALID(avctx, ctx)          (ctx->d3d11va.decoder && ctx->d3d11va.cfg && ctx->d3d11va.surface_count)
++#define DXVA_CONTEXT_VALID(avctx, ctx)          (ctx->d3d11va.decoder && ctx->d3d11va.cfg)
+ #endif
+ 
+ unsigned ff_dxva2_get_surface_index(const AVCodecContext *avctx,
+diff --git a/libavcodec/version.h b/libavcodec/version.h
+index c28867a..69aae45 100644
+--- a/libavcodec/version.h
++++ b/libavcodec/version.h
+@@ -29,7 +29,7 @@
+ 
+ #define LIBAVCODEC_VERSION_MAJOR  57
+ #define LIBAVCODEC_VERSION_MINOR  66
+-#define LIBAVCODEC_VERSION_MICRO 108
++#define LIBAVCODEC_VERSION_MICRO 109
+ 
+ #define LIBAVCODEC_VERSION_INT  AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, \
+                                                LIBAVCODEC_VERSION_MINOR, \
+-- 
+2.10.1.windows.1
+
diff --git a/contrib/src/ffmpeg/rules.mak b/contrib/src/ffmpeg/rules.mak
index 20e9b79..179354f 100644
--- a/contrib/src/ffmpeg/rules.mak
+++ b/contrib/src/ffmpeg/rules.mak
@@ -5,9 +5,10 @@
 USE_FFMPEG ?= 1
 
 ifdef USE_FFMPEG
-FFMPEG_HASH=9b462a0b9df6260f59726c98d8aef8b07a1e442b
+FFMPEG_HASH=d44af9a38e6b116e1a89b2862f4d4f8cb9855387
 FFMPEG_SNAPURL := http://git.videolan.org/?p=ffmpeg.git;a=snapshot;h=$(FFMPEG_HASH);sf=tgz
 FFMPEG_GITURL := http://git.videolan.org/git/ffmpeg.git
+PATCH_SUFFIX =.ffmpeg
 else
 FFMPEG_HASH=HEAD
 FFMPEG_SNAPURL := http://git.libav.org/?p=libav.git;a=snapshot;h=$(FFMPEG_HASH);sf=tgz
@@ -221,6 +222,9 @@ ffmpeg: ffmpeg-$(FFMPEG_HASH).tar.xz .sum-ffmpeg
 	rm -Rf $@ $@-$(FFMPEG_HASH)
 	mkdir -p $@-$(FFMPEG_HASH)
 	$(XZCAT) "$<" | (cd $@-$(FFMPEG_HASH) && tar xv --strip-components=1)
+	$(APPLY) $(SRC)/ffmpeg/0001-dxva2-use-a-single-macro-to-test-if-the-DXVA-context.patch$(PATCH_SUFFIX)
+	$(APPLY) $(SRC)/ffmpeg/0002-dxva2-get-the-slice-number-directly-from-the-surface.patch$(PATCH_SUFFIX)
+	$(APPLY) $(SRC)/ffmpeg/0003-dxva2-allow-an-empty-array-of-ID3D11VideoDecoderOutp.patch$(PATCH_SUFFIX)
 	$(MOVE)
 
 .ffmpeg: ffmpeg
-- 
2.10.1.windows.1

